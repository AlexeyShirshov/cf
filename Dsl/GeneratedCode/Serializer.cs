//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslDiagrams = global::Microsoft.VisualStudio.Modeling.Diagrams;

namespace Worm.Designer
{
	/// <summary>
	/// Serializer WormModelSerializer for DomainClass WormModel.
	/// </summary>
	public partial class WormModelSerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// WormModelSerializer Constructor
		/// </summary>
		public WormModelSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of WormModel.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"wormModel"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of WormModel.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"wormModelMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of WormModel in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one WormModel instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the WormModel element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormModel instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormModel instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			WormModel instanceOfWormModel = element as WormModel;
			global::System.Diagnostics.Debug.Assert(instanceOfWormModel != null, "Expecting an instance of WormModel");
	
			// DefaultNamespace
			if (!serializationContext.Result.Failed)
			{
				string attribDefaultNamespace = reader.GetAttribute("defaultNamespace");
				if (attribDefaultNamespace != null)
				{
					global::System.String valueOfDefaultNamespace;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribDefaultNamespace), out valueOfDefaultNamespace))
					{
						instanceOfWormModel.DefaultNamespace = valueOfDefaultNamespace;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "defaultNamespace", typeof(global::System.String), attribDefaultNamespace);
					}
				}
			}
			// SchemaVersion
			if (!serializationContext.Result.Failed)
			{
				string attribSchemaVersion = reader.GetAttribute("schemaVersion");
				if (attribSchemaVersion != null)
				{
					global::System.String valueOfSchemaVersion;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSchemaVersion), out valueOfSchemaVersion))
					{
						instanceOfWormModel.SchemaVersion = valueOfSchemaVersion;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "schemaVersion", typeof(global::System.String), attribSchemaVersion);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormModel instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			WormModel instanceOfWormModel = element as WormModel;
			global::System.Diagnostics.Debug.Assert(instanceOfWormModel != null, "Expecting an instance of WormModel!");
	
			// Read child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				ReadChildElements(serializationContext, instanceOfWormModel, reader);
		}
	
		/// <summary>
		/// This method deserializes all child model elements.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element to deserialized.
		/// This method will read as many child elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
		///    open tag of the unknown element. This implies the if the first child XML element is unknown, this method 
		///    should return immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="element">In-memory WormModel instance that will get the deserialized data.</param>
		private static void ReadChildElements(DslModeling::SerializationContext serializationContext, WormModel element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
					case "entities":	// Relationship "WormModelHasEntities"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <entities>
							ReadWormModelHasEntitiesInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </entities>
						}
						break;
					case "tables":	// Relationship "WormModelHasTables"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <tables>
							ReadWormModelHasTablesInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </tables>
						}
						break;
					case "types":	// Relationship "WormModelHasTypes"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <types>
							ReadWormModelHasTypesInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </types>
						}
						break;
					default:
						return;  // Don't know this element.
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship WormModelHasEntities.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormModel instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadWormModelHasEntitiesInstances(DslModeling::SerializationContext serializationContext, WormModel element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newEntityOfWormModelHasEntitiesSerializer = serializationContext.Directory.GetSerializer(Entity.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newEntityOfWormModelHasEntitiesSerializer != null, "Cannot find serializer for Entity!");
				Entity newEntityOfWormModelHasEntities = newEntityOfWormModelHasEntitiesSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as Entity;
				if (newEntityOfWormModelHasEntities != null)
				{
					element.Entities.Add(newEntityOfWormModelHasEntities);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newEntityOfWormModelHasEntities.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newEntityOfWormModelHasEntities.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newEntityOfWormModelHasEntities, reader);
				}
				else
				{
					global::System.Type typeofWormModelHasEntities = typeof(WormModelHasEntities);
					DslModeling::DomainRelationshipXmlSerializer newWormModelHasEntitiesSerializer = serializationContext.Directory.GetSerializer(WormModelHasEntities.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newWormModelHasEntitiesSerializer != null, "Cannot find serializer for WormModelHasEntities!");
					WormModelHasEntities newWormModelHasEntities = newWormModelHasEntitiesSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as WormModelHasEntities;
					if (newWormModelHasEntities != null)
					{
						if (newWormModelHasEntities.GetType() == typeofWormModelHasEntities)
						{	// The relationship should be serialized in short-form.
							DesignerSerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(WormModelHasEntities));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newWormModelHasEntities, WormModelHasEntities.WormModelDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newWormModelHasEntities.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newWormModelHasEntities.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newWormModelHasEntities, reader);
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship WormModelHasTables.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormModel instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadWormModelHasTablesInstances(DslModeling::SerializationContext serializationContext, WormModel element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newTableOfWormModelHasTablesSerializer = serializationContext.Directory.GetSerializer(Table.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newTableOfWormModelHasTablesSerializer != null, "Cannot find serializer for Table!");
				Table newTableOfWormModelHasTables = newTableOfWormModelHasTablesSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as Table;
				if (newTableOfWormModelHasTables != null)
				{
					element.Tables.Add(newTableOfWormModelHasTables);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newTableOfWormModelHasTables.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newTableOfWormModelHasTables.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newTableOfWormModelHasTables, reader);
				}
				else
				{
					global::System.Type typeofWormModelHasTables = typeof(WormModelHasTables);
					DslModeling::DomainRelationshipXmlSerializer newWormModelHasTablesSerializer = serializationContext.Directory.GetSerializer(WormModelHasTables.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newWormModelHasTablesSerializer != null, "Cannot find serializer for WormModelHasTables!");
					WormModelHasTables newWormModelHasTables = newWormModelHasTablesSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as WormModelHasTables;
					if (newWormModelHasTables != null)
					{
						if (newWormModelHasTables.GetType() == typeofWormModelHasTables)
						{	// The relationship should be serialized in short-form.
							DesignerSerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(WormModelHasTables));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newWormModelHasTables, WormModelHasTables.WormModelDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newWormModelHasTables.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newWormModelHasTables.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newWormModelHasTables, reader);
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship WormModelHasTypes.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormModel instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadWormModelHasTypesInstances(DslModeling::SerializationContext serializationContext, WormModel element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newWormTypeOfWormModelHasTypesSerializer = serializationContext.Directory.GetSerializer(WormType.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newWormTypeOfWormModelHasTypesSerializer != null, "Cannot find serializer for WormType!");
				WormType newWormTypeOfWormModelHasTypes = newWormTypeOfWormModelHasTypesSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as WormType;
				if (newWormTypeOfWormModelHasTypes != null)
				{
					element.Types.Add(newWormTypeOfWormModelHasTypes);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newWormTypeOfWormModelHasTypes.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newWormTypeOfWormModelHasTypes.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newWormTypeOfWormModelHasTypes, reader);
				}
				else
				{
					global::System.Type typeofWormModelHasTypes = typeof(WormModelHasTypes);
					DslModeling::DomainRelationshipXmlSerializer newWormModelHasTypesSerializer = serializationContext.Directory.GetSerializer(WormModelHasTypes.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newWormModelHasTypesSerializer != null, "Cannot find serializer for WormModelHasTypes!");
					WormModelHasTypes newWormModelHasTypes = newWormModelHasTypesSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as WormModelHasTypes;
					if (newWormModelHasTypes != null)
					{
						if (newWormModelHasTypes.GetType() == typeofWormModelHasTypes)
						{	// The relationship should be serialized in short-form.
							DesignerSerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(WormModelHasTypes));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newWormModelHasTypes, WormModelHasTypes.WormModelDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newWormModelHasTypes.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newWormModelHasTypes.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newWormModelHasTypes, reader);
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of WormModel based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized WormModel, a new WormModel instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created WormModel instance, or null if the reader is not pointing to a serialized WormModel instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "WormModel" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "WormModel".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						WormModelSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as WormModelSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of WormModel based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of WormModel.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new WormModel instance should be created.</param>	
		/// <returns>Created WormModel instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DesignerSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new WormModel(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DesignerSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DesignerSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DesignerSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from WormModel, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from WormModel.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(WormModel.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including WormModel itself) instance of WormModel based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "WormModel" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "WormModel".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						WormModelSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as WormModelSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of WormModel based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DslModeling::SerializationUtilities.UnescapeXmlString(reader.GetAttribute(this.MonikerAttributeName));
			if (string.IsNullOrEmpty(monikerString))
			{	
				DesignerSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, WormModel.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DesignerSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DesignerSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from WormModel, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from WormModel.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(WormModel.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized WormModel instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormModel instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the WormModel instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the WormModel instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			writer.WriteAttributeString(this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one WormModel instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormModel instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormModel instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			WormModel instanceOfWormModel = element as WormModel;
			global::System.Diagnostics.Debug.Assert(instanceOfWormModel != null, "Expecting an instance of WormModel");
	
			// DefaultNamespace
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfWormModel.DefaultNamespace;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("defaultNamespace", propValue);
				}
			}
			// SchemaVersion
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfWormModel.SchemaVersion;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "1") != 0))
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("schemaVersion", propValue);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormModel instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			WormModel instance = element as WormModel;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of WormModel!");
	
			// Write child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed)
				WriteChildElements(serializationContext, instance, writer);
		}
	
		/// <summary>
		/// Serialize all child model elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormModel instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		private static void WriteChildElements(DslModeling::SerializationContext serializationContext, WormModel element, global::System.Xml.XmlWriter writer)
		{
			// WormModelHasEntities
			global::System.Collections.ObjectModel.ReadOnlyCollection<WormModelHasEntities> allWormModelHasEntitiesInstances = WormModelHasEntities.GetLinksToEntities(element);
			if (!serializationContext.Result.Failed && allWormModelHasEntitiesInstances.Count > 0)
			{
				writer.WriteStartElement("entities");
				global::System.Type typeofWormModelHasEntities = typeof(WormModelHasEntities);
				foreach (WormModelHasEntities eachWormModelHasEntitiesInstance in allWormModelHasEntitiesInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					if (eachWormModelHasEntitiesInstance.GetType() != typeofWormModelHasEntities)
					{	// Derived relationships will be serialized in full-form.
						DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachWormModelHasEntitiesInstance.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachWormModelHasEntitiesInstance.GetDomainClass().Name + "!");			
						derivedRelSerializer.Write(serializationContext, eachWormModelHasEntitiesInstance, writer);
					}
					else
					{	// No need to serialize the relationship itself, just serialize the role-player directly.
						DslModeling::ModelElement targetElement = eachWormModelHasEntitiesInstance.Entity;
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
						targetSerializer.Write(serializationContext, targetElement, writer);
					}
				}
				writer.WriteEndElement();
			}
	
			// WormModelHasTables
			global::System.Collections.ObjectModel.ReadOnlyCollection<WormModelHasTables> allWormModelHasTablesInstances = WormModelHasTables.GetLinksToTables(element);
			if (!serializationContext.Result.Failed && allWormModelHasTablesInstances.Count > 0)
			{
				writer.WriteStartElement("tables");
				global::System.Type typeofWormModelHasTables = typeof(WormModelHasTables);
				foreach (WormModelHasTables eachWormModelHasTablesInstance in allWormModelHasTablesInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					if (eachWormModelHasTablesInstance.GetType() != typeofWormModelHasTables)
					{	// Derived relationships will be serialized in full-form.
						DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachWormModelHasTablesInstance.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachWormModelHasTablesInstance.GetDomainClass().Name + "!");			
						derivedRelSerializer.Write(serializationContext, eachWormModelHasTablesInstance, writer);
					}
					else
					{	// No need to serialize the relationship itself, just serialize the role-player directly.
						DslModeling::ModelElement targetElement = eachWormModelHasTablesInstance.Table;
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
						targetSerializer.Write(serializationContext, targetElement, writer);
					}
				}
				writer.WriteEndElement();
			}
	
			// WormModelHasTypes
			global::System.Collections.ObjectModel.ReadOnlyCollection<WormModelHasTypes> allWormModelHasTypesInstances = WormModelHasTypes.GetLinksToTypes(element);
			if (!serializationContext.Result.Failed && allWormModelHasTypesInstances.Count > 0)
			{
				writer.WriteStartElement("types");
				global::System.Type typeofWormModelHasTypes = typeof(WormModelHasTypes);
				foreach (WormModelHasTypes eachWormModelHasTypesInstance in allWormModelHasTypesInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					if (eachWormModelHasTypesInstance.GetType() != typeofWormModelHasTypes)
					{	// Derived relationships will be serialized in full-form.
						DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachWormModelHasTypesInstance.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachWormModelHasTypesInstance.GetDomainClass().Name + "!");			
						derivedRelSerializer.Write(serializationContext, eachWormModelHasTypesInstance, writer);
					}
					else
					{	// No need to serialize the relationship itself, just serialize the role-player directly.
						DslModeling::ModelElement targetElement = eachWormModelHasTypesInstance.WormType;
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
						targetSerializer.Write(serializationContext, targetElement, writer);
					}
				}
				writer.WriteEndElement();
			}
	
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given WormModel instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">WormModel instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the WormModel instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			WormModel instance = element as WormModel;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of WormModel!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">WormModel instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace Worm.Designer
{
	/// <summary>
	/// Serializer EntitySerializer for DomainClass Entity.
	/// </summary>
	public partial class EntitySerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// EntitySerializer Constructor
		/// </summary>
		public EntitySerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of Entity.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"entity"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of Entity.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"entityMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of Entity in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one Entity instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the Entity element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Entity instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Entity instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			Entity instanceOfEntity = element as Entity;
			global::System.Diagnostics.Debug.Assert(instanceOfEntity != null, "Expecting an instance of Entity");
	
			// Name
			if (!serializationContext.Result.Failed)
			{
				string attribName = reader.GetAttribute("name");
				if (attribName != null)
				{
					global::System.String valueOfName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribName), out valueOfName))
					{
						instanceOfEntity.Name = valueOfName;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "name", typeof(global::System.String), attribName);
					}
				}
			}
			// Namespace
			if (!serializationContext.Result.Failed)
			{
				string attribNamespace = reader.GetAttribute("namespace");
				if (attribNamespace != null)
				{
					global::System.String valueOfNamespace;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribNamespace), out valueOfNamespace))
					{
						instanceOfEntity.Namespace = valueOfNamespace;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "namespace", typeof(global::System.String), attribNamespace);
					}
				}
			}
			// Behaviour
			if (!serializationContext.Result.Failed)
			{
				string attribBehaviour = reader.GetAttribute("behaviour");
				if (attribBehaviour != null)
				{
					global::Worm.CodeGen.Core.EntityBehaviuor valueOfBehaviour;
					if (DslModeling::SerializationUtilities.TryGetValue<global::Worm.CodeGen.Core.EntityBehaviuor>(DslModeling::SerializationUtilities.UnescapeXmlString(attribBehaviour), out valueOfBehaviour))
					{
						instanceOfEntity.Behaviour = valueOfBehaviour;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "behaviour", typeof(global::Worm.CodeGen.Core.EntityBehaviuor), attribBehaviour);
					}
				}
			}
			// Description
			if (!serializationContext.Result.Failed)
			{
				string attribDescription = reader.GetAttribute("description");
				if (attribDescription != null)
				{
					global::System.String valueOfDescription;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribDescription), out valueOfDescription))
					{
						instanceOfEntity.Description = valueOfDescription;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "description", typeof(global::System.String), attribDescription);
					}
				}
			}
			// UseGenerics
			if (!serializationContext.Result.Failed)
			{
				string attribUseGenerics = reader.GetAttribute("useGenerics");
				if (attribUseGenerics != null)
				{
					global::System.Boolean valueOfUseGenerics;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribUseGenerics), out valueOfUseGenerics))
					{
						instanceOfEntity.UseGenerics = valueOfUseGenerics;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "useGenerics", typeof(global::System.Boolean), attribUseGenerics);
					}
				}
			}
			// MakeInterface
			if (!serializationContext.Result.Failed)
			{
				string attribMakeInterface = reader.GetAttribute("makeInterface");
				if (attribMakeInterface != null)
				{
					global::System.Boolean valueOfMakeInterface;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribMakeInterface), out valueOfMakeInterface))
					{
						instanceOfEntity.MakeInterface = valueOfMakeInterface;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "makeInterface", typeof(global::System.Boolean), attribMakeInterface);
					}
				}
			}
			// BaseEntity
			if (!serializationContext.Result.Failed)
			{
				string attribBaseEntity = reader.GetAttribute("baseEntity");
				if (attribBaseEntity != null)
				{
					global::System.String valueOfBaseEntity;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribBaseEntity), out valueOfBaseEntity))
					{
						instanceOfEntity.BaseEntity = valueOfBaseEntity;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "baseEntity", typeof(global::System.String), attribBaseEntity);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Entity instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			Entity instanceOfEntity = element as Entity;
			global::System.Diagnostics.Debug.Assert(instanceOfEntity != null, "Expecting an instance of Entity!");
	
			// Read child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				ReadChildElements(serializationContext, instanceOfEntity, reader);
		}
	
		/// <summary>
		/// This method deserializes all child model elements.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element to deserialized.
		/// This method will read as many child elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
		///    open tag of the unknown element. This implies the if the first child XML element is unknown, this method 
		///    should return immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="element">In-memory Entity instance that will get the deserialized data.</param>
		private static void ReadChildElements(DslModeling::SerializationContext serializationContext, Entity element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
					case "properties":	// Relationship "EntityHasProperties"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <properties>
							ReadEntityHasPropertiesInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </properties>
						}
						break;
					case "targetEntities":	// Relationship "EntityReferencesTargetEntities"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <targetEntities>
							ReadEntityReferencesTargetEntitiesInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </targetEntities>
						}
						break;
					case "supressedProperties":	// Relationship "EntityHasSupressedProperties"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <supressedProperties>
							ReadEntityHasSupressedPropertiesInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </supressedProperties>
						}
						break;
					case "selfRelations":	// Relationship "EntityHasSelfRelations"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <selfRelations>
							ReadEntityHasSelfRelationsInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </selfRelations>
						}
						break;
					default:
						return;  // Don't know this element.
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship EntityHasProperties.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Entity instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadEntityHasPropertiesInstances(DslModeling::SerializationContext serializationContext, Entity element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newPropertyOfEntityHasPropertiesSerializer = serializationContext.Directory.GetSerializer(Property.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newPropertyOfEntityHasPropertiesSerializer != null, "Cannot find serializer for Property!");
				Property newPropertyOfEntityHasProperties = newPropertyOfEntityHasPropertiesSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as Property;
				if (newPropertyOfEntityHasProperties != null)
				{
					element.Properties.Add(newPropertyOfEntityHasProperties);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newPropertyOfEntityHasProperties.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newPropertyOfEntityHasProperties.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newPropertyOfEntityHasProperties, reader);
				}
				else
				{
					global::System.Type typeofEntityHasProperties = typeof(EntityHasProperties);
					DslModeling::DomainRelationshipXmlSerializer newEntityHasPropertiesSerializer = serializationContext.Directory.GetSerializer(EntityHasProperties.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newEntityHasPropertiesSerializer != null, "Cannot find serializer for EntityHasProperties!");
					EntityHasProperties newEntityHasProperties = newEntityHasPropertiesSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as EntityHasProperties;
					if (newEntityHasProperties != null)
					{
						if (newEntityHasProperties.GetType() == typeofEntityHasProperties)
						{	// The relationship should be serialized in short-form.
							DesignerSerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(EntityHasProperties));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newEntityHasProperties, EntityHasProperties.EntityDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newEntityHasProperties.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newEntityHasProperties.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newEntityHasProperties, reader);
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship EntityReferencesTargetEntities.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Entity instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
		private static void ReadEntityReferencesTargetEntitiesInstances(DslModeling::SerializationContext serializationContext, Entity element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newEntityReferencesTargetEntitiesSerializer = serializationContext.Directory.GetSerializer(EntityReferencesTargetEntities.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newEntityReferencesTargetEntitiesSerializer != null, "Cannot find serializer for EntityReferencesTargetEntities!");
				EntityReferencesTargetEntities newEntityReferencesTargetEntities = newEntityReferencesTargetEntitiesSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as EntityReferencesTargetEntities;
				if (newEntityReferencesTargetEntities != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newEntityReferencesTargetEntities, EntityReferencesTargetEntities.SourceEntityDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newEntityReferencesTargetEntities.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newEntityReferencesTargetEntities.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newEntityReferencesTargetEntities, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newEntityMonikerOfEntityReferencesTargetEntitiesSerializer = serializationContext.Directory.GetSerializer(Entity.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newEntityMonikerOfEntityReferencesTargetEntitiesSerializer != null, "Cannot find serializer for Entity!");
					DslModeling::Moniker newEntityMonikerOfEntityReferencesTargetEntities = newEntityMonikerOfEntityReferencesTargetEntitiesSerializer.TryCreateMonikerInstance(serializationContext, reader, element, EntityReferencesTargetEntities.DomainClassId, element.Partition);
					if (newEntityMonikerOfEntityReferencesTargetEntities != null)
					{
						DesignerSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(EntityReferencesTargetEntities));
						new EntityReferencesTargetEntities(element.Partition, new DslModeling::RoleAssignment(EntityReferencesTargetEntities.SourceEntityDomainRoleId, element), new DslModeling::RoleAssignment(EntityReferencesTargetEntities.TargetEntityDomainRoleId, newEntityMonikerOfEntityReferencesTargetEntities));
						DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship EntityHasSupressedProperties.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Entity instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadEntityHasSupressedPropertiesInstances(DslModeling::SerializationContext serializationContext, Entity element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newSupressedPropertyOfEntityHasSupressedPropertiesSerializer = serializationContext.Directory.GetSerializer(SupressedProperty.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newSupressedPropertyOfEntityHasSupressedPropertiesSerializer != null, "Cannot find serializer for SupressedProperty!");
				SupressedProperty newSupressedPropertyOfEntityHasSupressedProperties = newSupressedPropertyOfEntityHasSupressedPropertiesSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as SupressedProperty;
				if (newSupressedPropertyOfEntityHasSupressedProperties != null)
				{
					element.SupressedProperties.Add(newSupressedPropertyOfEntityHasSupressedProperties);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newSupressedPropertyOfEntityHasSupressedProperties.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newSupressedPropertyOfEntityHasSupressedProperties.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newSupressedPropertyOfEntityHasSupressedProperties, reader);
				}
				else
				{
					global::System.Type typeofEntityHasSupressedProperties = typeof(EntityHasSupressedProperties);
					DslModeling::DomainRelationshipXmlSerializer newEntityHasSupressedPropertiesSerializer = serializationContext.Directory.GetSerializer(EntityHasSupressedProperties.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newEntityHasSupressedPropertiesSerializer != null, "Cannot find serializer for EntityHasSupressedProperties!");
					EntityHasSupressedProperties newEntityHasSupressedProperties = newEntityHasSupressedPropertiesSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as EntityHasSupressedProperties;
					if (newEntityHasSupressedProperties != null)
					{
						if (newEntityHasSupressedProperties.GetType() == typeofEntityHasSupressedProperties)
						{	// The relationship should be serialized in short-form.
							DesignerSerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(EntityHasSupressedProperties));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newEntityHasSupressedProperties, EntityHasSupressedProperties.EntityDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newEntityHasSupressedProperties.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newEntityHasSupressedProperties.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newEntityHasSupressedProperties, reader);
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship EntityHasSelfRelations.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Entity instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadEntityHasSelfRelationsInstances(DslModeling::SerializationContext serializationContext, Entity element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newSelfRelationOfEntityHasSelfRelationsSerializer = serializationContext.Directory.GetSerializer(SelfRelation.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newSelfRelationOfEntityHasSelfRelationsSerializer != null, "Cannot find serializer for SelfRelation!");
				SelfRelation newSelfRelationOfEntityHasSelfRelations = newSelfRelationOfEntityHasSelfRelationsSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as SelfRelation;
				if (newSelfRelationOfEntityHasSelfRelations != null)
				{
					element.SelfRelations.Add(newSelfRelationOfEntityHasSelfRelations);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newSelfRelationOfEntityHasSelfRelations.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newSelfRelationOfEntityHasSelfRelations.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newSelfRelationOfEntityHasSelfRelations, reader);
				}
				else
				{
					global::System.Type typeofEntityHasSelfRelations = typeof(EntityHasSelfRelations);
					DslModeling::DomainRelationshipXmlSerializer newEntityHasSelfRelationsSerializer = serializationContext.Directory.GetSerializer(EntityHasSelfRelations.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newEntityHasSelfRelationsSerializer != null, "Cannot find serializer for EntityHasSelfRelations!");
					EntityHasSelfRelations newEntityHasSelfRelations = newEntityHasSelfRelationsSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as EntityHasSelfRelations;
					if (newEntityHasSelfRelations != null)
					{
						if (newEntityHasSelfRelations.GetType() == typeofEntityHasSelfRelations)
						{	// The relationship should be serialized in short-form.
							DesignerSerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(EntityHasSelfRelations));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newEntityHasSelfRelations, EntityHasSelfRelations.EntityDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newEntityHasSelfRelations.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newEntityHasSelfRelations.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newEntityHasSelfRelations, reader);
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of Entity based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized Entity, a new Entity instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created Entity instance, or null if the reader is not pointing to a serialized Entity instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Entity" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "Entity".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						EntitySerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EntitySerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of Entity based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of Entity.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new Entity instance should be created.</param>	
		/// <returns>Created Entity instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DesignerSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new Entity(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DesignerSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DesignerSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DesignerSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from Entity, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from Entity.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Entity.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including Entity itself) instance of Entity based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Entity" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "Entity".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						EntitySerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EntitySerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of Entity based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DslModeling::SerializationUtilities.UnescapeXmlString(reader.GetAttribute(this.MonikerAttributeName));
			if (string.IsNullOrEmpty(monikerString))
			{	
				DesignerSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, Entity.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DesignerSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DesignerSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from Entity, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from Entity.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Entity.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized Entity instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Entity instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the Entity instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the Entity instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			writer.WriteAttributeString(this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one Entity instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Entity instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Entity instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			Entity instanceOfEntity = element as Entity;
			global::System.Diagnostics.Debug.Assert(instanceOfEntity != null, "Expecting an instance of Entity");
	
			// Name
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfEntity.Name;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "Entity") != 0))
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("name", propValue);
					}
				}
			}
			// Namespace
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfEntity.Namespace;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("namespace", propValue);
				}
			}
			// Behaviour
			if (!serializationContext.Result.Failed)
			{
				global::Worm.CodeGen.Core.EntityBehaviuor propValue = instanceOfEntity.Behaviour;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::Worm.CodeGen.Core.EntityBehaviuor>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Default") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("behaviour", serializedPropValue);
					}
				}
			}
			// Description
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfEntity.Description;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("description", propValue);
				}
			}
			// UseGenerics
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfEntity.UseGenerics;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("useGenerics", serializedPropValue);
					}
				}
			}
			// MakeInterface
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfEntity.MakeInterface;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					writer.WriteAttributeString("makeInterface", serializedPropValue);
				}
			}
			// BaseEntity
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfEntity.BaseEntity;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("baseEntity", propValue);
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Entity instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			Entity instance = element as Entity;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Entity!");
	
			// Write child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed)
				WriteChildElements(serializationContext, instance, writer);
		}
	
		/// <summary>
		/// Serialize all child model elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Entity instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		private static void WriteChildElements(DslModeling::SerializationContext serializationContext, Entity element, global::System.Xml.XmlWriter writer)
		{
			// EntityHasProperties
			global::System.Collections.ObjectModel.ReadOnlyCollection<EntityHasProperties> allEntityHasPropertiesInstances = EntityHasProperties.GetLinksToProperties(element);
			if (!serializationContext.Result.Failed && allEntityHasPropertiesInstances.Count > 0)
			{
				writer.WriteStartElement("properties");
				global::System.Type typeofEntityHasProperties = typeof(EntityHasProperties);
				foreach (EntityHasProperties eachEntityHasPropertiesInstance in allEntityHasPropertiesInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					if (eachEntityHasPropertiesInstance.GetType() != typeofEntityHasProperties)
					{	// Derived relationships will be serialized in full-form.
						DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachEntityHasPropertiesInstance.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachEntityHasPropertiesInstance.GetDomainClass().Name + "!");			
						derivedRelSerializer.Write(serializationContext, eachEntityHasPropertiesInstance, writer);
					}
					else
					{	// No need to serialize the relationship itself, just serialize the role-player directly.
						DslModeling::ModelElement targetElement = eachEntityHasPropertiesInstance.Property;
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
						targetSerializer.Write(serializationContext, targetElement, writer);
					}
				}
				writer.WriteEndElement();
			}
	
			// EntityReferencesTargetEntities
			global::System.Collections.ObjectModel.ReadOnlyCollection<EntityReferencesTargetEntities> allEntityReferencesTargetEntitiesInstances = EntityReferencesTargetEntities.GetLinksToTargetEntities(element);
			if (!serializationContext.Result.Failed && allEntityReferencesTargetEntitiesInstances.Count > 0)
			{
				writer.WriteStartElement("targetEntities");
				foreach (EntityReferencesTargetEntities eachEntityReferencesTargetEntitiesInstance in allEntityReferencesTargetEntitiesInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachEntityReferencesTargetEntitiesInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachEntityReferencesTargetEntitiesInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachEntityReferencesTargetEntitiesInstance, writer);
				}
				writer.WriteEndElement();
			}
	
			// EntityHasSupressedProperties
			global::System.Collections.ObjectModel.ReadOnlyCollection<EntityHasSupressedProperties> allEntityHasSupressedPropertiesInstances = EntityHasSupressedProperties.GetLinksToSupressedProperties(element);
			if (!serializationContext.Result.Failed && allEntityHasSupressedPropertiesInstances.Count > 0)
			{
				writer.WriteStartElement("supressedProperties");
				global::System.Type typeofEntityHasSupressedProperties = typeof(EntityHasSupressedProperties);
				foreach (EntityHasSupressedProperties eachEntityHasSupressedPropertiesInstance in allEntityHasSupressedPropertiesInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					if (eachEntityHasSupressedPropertiesInstance.GetType() != typeofEntityHasSupressedProperties)
					{	// Derived relationships will be serialized in full-form.
						DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachEntityHasSupressedPropertiesInstance.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachEntityHasSupressedPropertiesInstance.GetDomainClass().Name + "!");			
						derivedRelSerializer.Write(serializationContext, eachEntityHasSupressedPropertiesInstance, writer);
					}
					else
					{	// No need to serialize the relationship itself, just serialize the role-player directly.
						DslModeling::ModelElement targetElement = eachEntityHasSupressedPropertiesInstance.SupressedProperty;
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
						targetSerializer.Write(serializationContext, targetElement, writer);
					}
				}
				writer.WriteEndElement();
			}
	
			// EntityHasSelfRelations
			global::System.Collections.ObjectModel.ReadOnlyCollection<EntityHasSelfRelations> allEntityHasSelfRelationsInstances = EntityHasSelfRelations.GetLinksToSelfRelations(element);
			if (!serializationContext.Result.Failed && allEntityHasSelfRelationsInstances.Count > 0)
			{
				writer.WriteStartElement("selfRelations");
				global::System.Type typeofEntityHasSelfRelations = typeof(EntityHasSelfRelations);
				foreach (EntityHasSelfRelations eachEntityHasSelfRelationsInstance in allEntityHasSelfRelationsInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					if (eachEntityHasSelfRelationsInstance.GetType() != typeofEntityHasSelfRelations)
					{	// Derived relationships will be serialized in full-form.
						DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachEntityHasSelfRelationsInstance.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachEntityHasSelfRelationsInstance.GetDomainClass().Name + "!");			
						derivedRelSerializer.Write(serializationContext, eachEntityHasSelfRelationsInstance, writer);
					}
					else
					{	// No need to serialize the relationship itself, just serialize the role-player directly.
						DslModeling::ModelElement targetElement = eachEntityHasSelfRelationsInstance.SelfRelation;
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
						targetSerializer.Write(serializationContext, targetElement, writer);
					}
				}
				writer.WriteEndElement();
			}
	
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given Entity instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Entity instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the Entity instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Entity instance = element as Entity;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Entity!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Entity instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace Worm.Designer
{
	/// <summary>
	/// Serializer TableSerializer for DomainClass Table.
	/// </summary>
	public partial class TableSerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// TableSerializer Constructor
		/// </summary>
		public TableSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of Table.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"table"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one Table instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the Table element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Table instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Table instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			Table instanceOfTable = element as Table;
			global::System.Diagnostics.Debug.Assert(instanceOfTable != null, "Expecting an instance of Table");
	
			// Name
			if (!serializationContext.Result.Failed)
			{
				string attribName = reader.GetAttribute("name");
				if (attribName != null)
				{
					global::System.String valueOfName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribName), out valueOfName))
					{
						instanceOfTable.Name = valueOfName;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "name", typeof(global::System.String), attribName);
					}
				}
			}
			// Schema
			if (!serializationContext.Result.Failed)
			{
				string attribSchema = reader.GetAttribute("schema");
				if (attribSchema != null)
				{
					global::System.String valueOfSchema;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSchema), out valueOfSchema))
					{
						instanceOfTable.Schema = valueOfSchema;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "schema", typeof(global::System.String), attribSchema);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Table instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			Table instanceOfTable = element as Table;
			global::System.Diagnostics.Debug.Assert(instanceOfTable != null, "Expecting an instance of Table!");
	
			// Read child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				ReadChildElements(serializationContext, instanceOfTable, reader);
		}
	
		/// <summary>
		/// This method deserializes all child model elements.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element to deserialized.
		/// This method will read as many child elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
		///    open tag of the unknown element. This implies the if the first child XML element is unknown, this method 
		///    should return immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="element">In-memory Table instance that will get the deserialized data.</param>
		private static void ReadChildElements(DslModeling::SerializationContext serializationContext, Table element, global::System.Xml.XmlReader reader)
		{
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				if (string.Compare(reader.LocalName, "entity", global::System.StringComparison.CurrentCulture) == 0)
				{
					if (reader.IsEmptyElement)
					{	// No instance of this relationship, just skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
					else
					{
						DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <entity>
						ReadTableReferencesEntityInstance(serializationContext, element, reader);
						DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </entity>
					}
				}
			}
		}
	
		/// <summary>
		/// Reads instance of relationship TableReferencesEntity.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize only the first valid instance and ignore all the
		/// rest tags (because the multiplicity allows only one instance). When the method returns, the reader will be positioned at 
		/// the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Table instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
		private static void ReadTableReferencesEntityInstance(DslModeling::SerializationContext serializationContext, Table element, global::System.Xml.XmlReader reader)
		{
			if (DslModeling::DomainRoleInfo.GetElementLinks<TableReferencesEntity> (element, TableReferencesEntity.TableDomainRoleId).Count > 0)
			{	// Only allow one instance, which already exists, so skip everything
				DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
				return;
			}
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newEntityMonikerOfTableReferencesEntitySerializer = serializationContext.Directory.GetSerializer(Entity.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newEntityMonikerOfTableReferencesEntitySerializer != null, "Cannot find serializer for Entity!");
				DslModeling::Moniker newEntityMonikerOfTableReferencesEntity = newEntityMonikerOfTableReferencesEntitySerializer.TryCreateMonikerInstance(serializationContext, reader, element, TableReferencesEntity.DomainClassId, element.Partition);
				if (newEntityMonikerOfTableReferencesEntity != null)
				{
					new TableReferencesEntity(element.Partition, new DslModeling::RoleAssignment(TableReferencesEntity.TableDomainRoleId, element), new DslModeling::RoleAssignment(TableReferencesEntity.EntityDomainRoleId, newEntityMonikerOfTableReferencesEntity));
					DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
					break;	// Only allow one instance.
				}
				else
				{
					global::System.Type typeofTableReferencesEntity = typeof(TableReferencesEntity);
					DslModeling::DomainRelationshipXmlSerializer newTableReferencesEntitySerializer = serializationContext.Directory.GetSerializer(TableReferencesEntity.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newTableReferencesEntitySerializer != null, "Cannot find serializer for TableReferencesEntity!");
					TableReferencesEntity newTableReferencesEntity = newTableReferencesEntitySerializer.TryCreateInstance (serializationContext, reader, element.Partition) as TableReferencesEntity;
					if (newTableReferencesEntity != null)
					{
						if (newTableReferencesEntity.GetType() == typeofTableReferencesEntity)
						{	// The relationship should be serialized in short-form.
							DesignerSerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(TableReferencesEntity));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newTableReferencesEntity, TableReferencesEntity.TableDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newTableReferencesEntity.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newTableReferencesEntity.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newTableReferencesEntity, reader);
						break;	// Only allow one instance.
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of Table based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized Table, a new Table instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created Table instance, or null if the reader is not pointing to a serialized Table instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Table" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "Table".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						TableSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TableSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of Table based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of Table.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new Table instance should be created.</param>	
		/// <returns>Created Table instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new Table(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from Table, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from Table.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Table.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including Table itself) instance of Table based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Table" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "Table".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						TableSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TableSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of Table based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from Table, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from Table.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Table.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized Table instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Table instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the Table instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the Table instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of Table cannot be monikerized.
			DesignerSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "Table");
		}
		
		/// <summary>
		/// Public Write() method that serializes one Table instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Table instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Table instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			Table instanceOfTable = element as Table;
			global::System.Diagnostics.Debug.Assert(instanceOfTable != null, "Expecting an instance of Table");
	
			// Name
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfTable.Name;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("name", propValue);
				}
			}
			// Schema
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfTable.Schema;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "dbo") != 0))
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("schema", propValue);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Table instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			Table instance = element as Table;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Table!");
	
			// Write child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed)
				WriteChildElements(serializationContext, instance, writer);
		}
	
		/// <summary>
		/// Serialize all child model elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Table instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		private static void WriteChildElements(DslModeling::SerializationContext serializationContext, Table element, global::System.Xml.XmlWriter writer)
		{
			// TableReferencesEntity
			TableReferencesEntity theTableReferencesEntityInstance = TableReferencesEntity.GetLinkToEntity(element);
			if (!serializationContext.Result.Failed && theTableReferencesEntityInstance != null)
			{
				DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(TableReferencesEntity.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
				global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for TableReferencesEntity!");
	
				writer.WriteStartElement("entity");
				global::System.Type typeofTableReferencesEntity = typeof(TableReferencesEntity);
				if (theTableReferencesEntityInstance.GetType() != typeofTableReferencesEntity)
				{	// Derived relationships will be serialized in full-form.
					DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(theTableReferencesEntityInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + theTableReferencesEntityInstance.GetDomainClass().Name + "!");			
					derivedRelSerializer.Write(serializationContext, theTableReferencesEntityInstance, writer);
				}
				else
				{	// No need to serialize the relationship itself, just serialize the role-player directly.
					DslModeling::ModelElement targetElement = theTableReferencesEntityInstance.Entity;
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
					targetSerializer.WriteMoniker(serializationContext, targetElement, writer, element, relSerializer);
				}
				writer.WriteEndElement();
			}
	
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given Table instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Table instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the Table instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Table instance = element as Table;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Table!");
	
			DslModeling::ModelElement container = instance.WormModel;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Table instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Table instance = element as Table;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Table!");
			DslModeling::ModelElement container = instance.WormModel;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Worm.Designer
{
	/// <summary>
	/// Serializer PropertySerializer for DomainClass Property.
	/// </summary>
	public partial class PropertySerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// PropertySerializer Constructor
		/// </summary>
		public PropertySerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of Property.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"property"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one Property instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the Property element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Property instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Property instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			Property instanceOfProperty = element as Property;
			global::System.Diagnostics.Debug.Assert(instanceOfProperty != null, "Expecting an instance of Property");
	
			// Name
			if (!serializationContext.Result.Failed)
			{
				string attribName = reader.GetAttribute("name");
				if (attribName != null)
				{
					global::System.String valueOfName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribName), out valueOfName))
					{
						instanceOfProperty.Name = valueOfName;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "name", typeof(global::System.String), attribName);
					}
				}
			}
			// Type
			if (!serializationContext.Result.Failed)
			{
				string attribType = reader.GetAttribute("type");
				if (attribType != null)
				{
					global::System.String valueOfType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribType), out valueOfType))
					{
						instanceOfProperty.Type = valueOfType;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "type", typeof(global::System.String), attribType);
					}
				}
			}
			// Description
			if (!serializationContext.Result.Failed)
			{
				string attribDescription = reader.GetAttribute("description");
				if (attribDescription != null)
				{
					global::System.String valueOfDescription;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribDescription), out valueOfDescription))
					{
						instanceOfProperty.Description = valueOfDescription;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "description", typeof(global::System.String), attribDescription);
					}
				}
			}
			// FieldName
			if (!serializationContext.Result.Failed)
			{
				string attribFieldName = reader.GetAttribute("fieldName");
				if (attribFieldName != null)
				{
					global::System.String valueOfFieldName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribFieldName), out valueOfFieldName))
					{
						instanceOfProperty.FieldName = valueOfFieldName;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "fieldName", typeof(global::System.String), attribFieldName);
					}
				}
			}
			// Table
			if (!serializationContext.Result.Failed)
			{
				string attribTable = reader.GetAttribute("table");
				if (attribTable != null)
				{
					global::System.String valueOfTable;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTable), out valueOfTable))
					{
						instanceOfProperty.Table = valueOfTable;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "table", typeof(global::System.String), attribTable);
					}
				}
			}
			// FieldAccessLevel
			if (!serializationContext.Result.Failed)
			{
				string attribFieldAccessLevel = reader.GetAttribute("fieldAccessLevel");
				if (attribFieldAccessLevel != null)
				{
					global::Worm.CodeGen.Core.AccessLevel valueOfFieldAccessLevel;
					if (DslModeling::SerializationUtilities.TryGetValue<global::Worm.CodeGen.Core.AccessLevel>(DslModeling::SerializationUtilities.UnescapeXmlString(attribFieldAccessLevel), out valueOfFieldAccessLevel))
					{
						instanceOfProperty.FieldAccessLevel = valueOfFieldAccessLevel;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "fieldAccessLevel", typeof(global::Worm.CodeGen.Core.AccessLevel), attribFieldAccessLevel);
					}
				}
			}
			// Alias
			if (!serializationContext.Result.Failed)
			{
				string attribAlias = reader.GetAttribute("alias");
				if (attribAlias != null)
				{
					global::System.String valueOfAlias;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribAlias), out valueOfAlias))
					{
						instanceOfProperty.Alias = valueOfAlias;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "alias", typeof(global::System.String), attribAlias);
					}
				}
			}
			// AccessLevel
			if (!serializationContext.Result.Failed)
			{
				string attribAccessLevel = reader.GetAttribute("accessLevel");
				if (attribAccessLevel != null)
				{
					global::Worm.CodeGen.Core.AccessLevel valueOfAccessLevel;
					if (DslModeling::SerializationUtilities.TryGetValue<global::Worm.CodeGen.Core.AccessLevel>(DslModeling::SerializationUtilities.UnescapeXmlString(attribAccessLevel), out valueOfAccessLevel))
					{
						instanceOfProperty.AccessLevel = valueOfAccessLevel;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "accessLevel", typeof(global::Worm.CodeGen.Core.AccessLevel), attribAccessLevel);
					}
				}
			}
			// Nullable
			if (!serializationContext.Result.Failed)
			{
				string attribNullable = reader.GetAttribute("nullable");
				if (attribNullable != null)
				{
					global::System.Boolean valueOfNullable;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribNullable), out valueOfNullable))
					{
						instanceOfProperty.Nullable = valueOfNullable;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "nullable", typeof(global::System.Boolean), attribNullable);
					}
				}
			}
			// Attributes
			if (!serializationContext.Result.Failed)
			{
				string attribAttributes = reader.GetAttribute("attributes");
				if (attribAttributes != null)
				{
					global::System.String valueOfAttributes;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribAttributes), out valueOfAttributes))
					{
						instanceOfProperty.Attributes = valueOfAttributes;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "attributes", typeof(global::System.String), attribAttributes);
					}
				}
			}
			// Disabled
			if (!serializationContext.Result.Failed)
			{
				string attribDisabled = reader.GetAttribute("disabled");
				if (attribDisabled != null)
				{
					global::System.String valueOfDisabled;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribDisabled), out valueOfDisabled))
					{
						instanceOfProperty.Disabled = valueOfDisabled;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "disabled", typeof(global::System.String), attribDisabled);
					}
				}
			}
			// Obsolete
			if (!serializationContext.Result.Failed)
			{
				string attribObsolete = reader.GetAttribute("obsolete");
				if (attribObsolete != null)
				{
					Obsolete valueOfObsolete;
					if (DslModeling::SerializationUtilities.TryGetValue<Obsolete>(DslModeling::SerializationUtilities.UnescapeXmlString(attribObsolete), out valueOfObsolete))
					{
						instanceOfProperty.Obsolete = valueOfObsolete;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "obsolete", typeof(Obsolete), attribObsolete);
					}
				}
			}
			// ObsoleteDescription
			if (!serializationContext.Result.Failed)
			{
				string attribObsoleteDescription = reader.GetAttribute("obsoleteDescription");
				if (attribObsoleteDescription != null)
				{
					global::System.String valueOfObsoleteDescription;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribObsoleteDescription), out valueOfObsoleteDescription))
					{
						instanceOfProperty.ObsoleteDescription = valueOfObsoleteDescription;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "obsoleteDescription", typeof(global::System.String), attribObsoleteDescription);
					}
				}
			}
			// EnablePropertyChanged
			if (!serializationContext.Result.Failed)
			{
				string attribEnablePropertyChanged = reader.GetAttribute("enablePropertyChanged");
				if (attribEnablePropertyChanged != null)
				{
					global::System.String valueOfEnablePropertyChanged;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribEnablePropertyChanged), out valueOfEnablePropertyChanged))
					{
						instanceOfProperty.EnablePropertyChanged = valueOfEnablePropertyChanged;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "enablePropertyChanged", typeof(global::System.String), attribEnablePropertyChanged);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Property instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of Property based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized Property, a new Property instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created Property instance, or null if the reader is not pointing to a serialized Property instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Property" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "Property".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						PropertySerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as PropertySerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of Property based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of Property.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new Property instance should be created.</param>	
		/// <returns>Created Property instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new Property(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from Property, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from Property.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Property.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including Property itself) instance of Property based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Property" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "Property".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						PropertySerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as PropertySerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of Property based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from Property, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from Property.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Property.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized Property instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Property instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the Property instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the Property instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of Property cannot be monikerized.
			DesignerSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "Property");
		}
		
		/// <summary>
		/// Public Write() method that serializes one Property instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Property instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Property instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			Property instanceOfProperty = element as Property;
			global::System.Diagnostics.Debug.Assert(instanceOfProperty != null, "Expecting an instance of Property");
	
			// Name
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfProperty.Name;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("name", propValue);
				}
			}
			// Type
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfProperty.Type;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "System.String") != 0))
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("type", propValue);
					}
				}
			}
			// Description
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfProperty.Description;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("description", propValue);
				}
			}
			// FieldName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfProperty.FieldName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("fieldName", propValue);
				}
			}
			// Table
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfProperty.Table;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("table", propValue);
				}
			}
			// FieldAccessLevel
			if (!serializationContext.Result.Failed)
			{
				global::Worm.CodeGen.Core.AccessLevel propValue = instanceOfProperty.FieldAccessLevel;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::Worm.CodeGen.Core.AccessLevel>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Private") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("fieldAccessLevel", serializedPropValue);
					}
				}
			}
			// Alias
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfProperty.Alias;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("alias", propValue);
				}
			}
			// AccessLevel
			if (!serializationContext.Result.Failed)
			{
				global::Worm.CodeGen.Core.AccessLevel propValue = instanceOfProperty.AccessLevel;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::Worm.CodeGen.Core.AccessLevel>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Public") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("accessLevel", serializedPropValue);
					}
				}
			}
			// Nullable
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfProperty.Nullable;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("nullable", serializedPropValue);
					}
				}
			}
			// Attributes
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfProperty.Attributes;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("attributes", propValue);
				}
			}
			// Disabled
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfProperty.Disabled;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "false") != 0))
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("disabled", propValue);
					}
				}
			}
			// Obsolete
			if (!serializationContext.Result.Failed)
			{
				Obsolete propValue = instanceOfProperty.Obsolete;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<Obsolete>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "None") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("obsolete", serializedPropValue);
					}
				}
			}
			// ObsoleteDescription
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfProperty.ObsoleteDescription;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("obsoleteDescription", propValue);
				}
			}
			// EnablePropertyChanged
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfProperty.EnablePropertyChanged;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "False") != 0))
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("enablePropertyChanged", propValue);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Property instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given Property instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Property instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the Property instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Property instance = element as Property;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Property!");
	
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Property instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Property instance = element as Property;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Property!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Worm.Designer
{
	/// <summary>
	/// Serializer SupressedPropertySerializer for DomainClass SupressedProperty.
	/// </summary>
	public partial class SupressedPropertySerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// SupressedPropertySerializer Constructor
		/// </summary>
		public SupressedPropertySerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of SupressedProperty.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"supressedProperty"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one SupressedProperty instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the SupressedProperty element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory SupressedProperty instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory SupressedProperty instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			SupressedProperty instanceOfSupressedProperty = element as SupressedProperty;
			global::System.Diagnostics.Debug.Assert(instanceOfSupressedProperty != null, "Expecting an instance of SupressedProperty");
	
			// Name
			if (!serializationContext.Result.Failed)
			{
				string attribName = reader.GetAttribute("name");
				if (attribName != null)
				{
					global::System.String valueOfName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribName), out valueOfName))
					{
						instanceOfSupressedProperty.Name = valueOfName;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "name", typeof(global::System.String), attribName);
					}
				}
			}
			// Type
			if (!serializationContext.Result.Failed)
			{
				string attribType = reader.GetAttribute("type");
				if (attribType != null)
				{
					global::System.String valueOfType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribType), out valueOfType))
					{
						instanceOfSupressedProperty.Type = valueOfType;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "type", typeof(global::System.String), attribType);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory SupressedProperty instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of SupressedProperty based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized SupressedProperty, a new SupressedProperty instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created SupressedProperty instance, or null if the reader is not pointing to a serialized SupressedProperty instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "SupressedProperty" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "SupressedProperty".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						SupressedPropertySerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as SupressedPropertySerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of SupressedProperty based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of SupressedProperty.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new SupressedProperty instance should be created.</param>	
		/// <returns>Created SupressedProperty instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new SupressedProperty(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from SupressedProperty, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from SupressedProperty.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(SupressedProperty.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including SupressedProperty itself) instance of SupressedProperty based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "SupressedProperty" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "SupressedProperty".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						SupressedPropertySerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as SupressedPropertySerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of SupressedProperty based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from SupressedProperty, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from SupressedProperty.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(SupressedProperty.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized SupressedProperty instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">SupressedProperty instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the SupressedProperty instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the SupressedProperty instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of SupressedProperty cannot be monikerized.
			DesignerSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "SupressedProperty");
		}
		
		/// <summary>
		/// Public Write() method that serializes one SupressedProperty instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">SupressedProperty instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">SupressedProperty instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			SupressedProperty instanceOfSupressedProperty = element as SupressedProperty;
			global::System.Diagnostics.Debug.Assert(instanceOfSupressedProperty != null, "Expecting an instance of SupressedProperty");
	
			// Name
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfSupressedProperty.Name;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("name", propValue);
				}
			}
			// Type
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfSupressedProperty.Type;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "String") != 0))
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("type", propValue);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">SupressedProperty instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given SupressedProperty instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">SupressedProperty instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the SupressedProperty instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			SupressedProperty instance = element as SupressedProperty;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of SupressedProperty!");
	
			DslModeling::ModelElement container = instance.Entity;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">SupressedProperty instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			SupressedProperty instance = element as SupressedProperty;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of SupressedProperty!");
			DslModeling::ModelElement container = instance.Entity;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Worm.Designer
{
	/// <summary>
	/// Serializer SelfRelationSerializer for DomainClass SelfRelation.
	/// </summary>
	public partial class SelfRelationSerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// SelfRelationSerializer Constructor
		/// </summary>
		public SelfRelationSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of SelfRelation.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"selfRelation"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one SelfRelation instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the SelfRelation element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory SelfRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory SelfRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			SelfRelation instanceOfSelfRelation = element as SelfRelation;
			global::System.Diagnostics.Debug.Assert(instanceOfSelfRelation != null, "Expecting an instance of SelfRelation");
	
			// DirectAccessor
			if (!serializationContext.Result.Failed)
			{
				string attribDirectAccessor = reader.GetAttribute("directAccessor");
				if (attribDirectAccessor != null)
				{
					global::System.String valueOfDirectAccessor;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribDirectAccessor), out valueOfDirectAccessor))
					{
						instanceOfSelfRelation.DirectAccessor = valueOfDirectAccessor;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "directAccessor", typeof(global::System.String), attribDirectAccessor);
					}
				}
			}
			// DirectCascadeDelete
			if (!serializationContext.Result.Failed)
			{
				string attribDirectCascadeDelete = reader.GetAttribute("directCascadeDelete");
				if (attribDirectCascadeDelete != null)
				{
					global::System.Boolean valueOfDirectCascadeDelete;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribDirectCascadeDelete), out valueOfDirectCascadeDelete))
					{
						instanceOfSelfRelation.DirectCascadeDelete = valueOfDirectCascadeDelete;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "directCascadeDelete", typeof(global::System.Boolean), attribDirectCascadeDelete);
					}
				}
			}
			// DirectFieldName
			if (!serializationContext.Result.Failed)
			{
				string attribDirectFieldName = reader.GetAttribute("directFieldName");
				if (attribDirectFieldName != null)
				{
					global::System.String valueOfDirectFieldName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribDirectFieldName), out valueOfDirectFieldName))
					{
						instanceOfSelfRelation.DirectFieldName = valueOfDirectFieldName;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "directFieldName", typeof(global::System.String), attribDirectFieldName);
					}
				}
			}
			// Disabled
			if (!serializationContext.Result.Failed)
			{
				string attribDisabled = reader.GetAttribute("disabled");
				if (attribDisabled != null)
				{
					global::System.Boolean valueOfDisabled;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribDisabled), out valueOfDisabled))
					{
						instanceOfSelfRelation.Disabled = valueOfDisabled;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "disabled", typeof(global::System.Boolean), attribDisabled);
					}
				}
			}
			// ReverseAccessor
			if (!serializationContext.Result.Failed)
			{
				string attribReverseAccessor = reader.GetAttribute("reverseAccessor");
				if (attribReverseAccessor != null)
				{
					global::System.String valueOfReverseAccessor;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribReverseAccessor), out valueOfReverseAccessor))
					{
						instanceOfSelfRelation.ReverseAccessor = valueOfReverseAccessor;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "reverseAccessor", typeof(global::System.String), attribReverseAccessor);
					}
				}
			}
			// ReverseCascadeDelete
			if (!serializationContext.Result.Failed)
			{
				string attribReverseCascadeDelete = reader.GetAttribute("reverseCascadeDelete");
				if (attribReverseCascadeDelete != null)
				{
					global::System.Boolean valueOfReverseCascadeDelete;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribReverseCascadeDelete), out valueOfReverseCascadeDelete))
					{
						instanceOfSelfRelation.ReverseCascadeDelete = valueOfReverseCascadeDelete;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "reverseCascadeDelete", typeof(global::System.Boolean), attribReverseCascadeDelete);
					}
				}
			}
			// ReverseFieldName
			if (!serializationContext.Result.Failed)
			{
				string attribReverseFieldName = reader.GetAttribute("reverseFieldName");
				if (attribReverseFieldName != null)
				{
					global::System.String valueOfReverseFieldName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribReverseFieldName), out valueOfReverseFieldName))
					{
						instanceOfSelfRelation.ReverseFieldName = valueOfReverseFieldName;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "reverseFieldName", typeof(global::System.String), attribReverseFieldName);
					}
				}
			}
			// Table
			if (!serializationContext.Result.Failed)
			{
				string attribTable = reader.GetAttribute("table");
				if (attribTable != null)
				{
					global::System.String valueOfTable;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTable), out valueOfTable))
					{
						instanceOfSelfRelation.Table = valueOfTable;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "table", typeof(global::System.String), attribTable);
					}
				}
			}
			// UnderlyingEntity
			if (!serializationContext.Result.Failed)
			{
				string attribUnderlyingEntity = reader.GetAttribute("underlyingEntity");
				if (attribUnderlyingEntity != null)
				{
					global::System.String valueOfUnderlyingEntity;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribUnderlyingEntity), out valueOfUnderlyingEntity))
					{
						instanceOfSelfRelation.UnderlyingEntity = valueOfUnderlyingEntity;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "underlyingEntity", typeof(global::System.String), attribUnderlyingEntity);
					}
				}
			}
			// DirectAccessedEntityType
			if (!serializationContext.Result.Failed)
			{
				string attribDirectAccessedEntityType = reader.GetAttribute("directAccessedEntityType");
				if (attribDirectAccessedEntityType != null)
				{
					global::System.String valueOfDirectAccessedEntityType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribDirectAccessedEntityType), out valueOfDirectAccessedEntityType))
					{
						instanceOfSelfRelation.DirectAccessedEntityType = valueOfDirectAccessedEntityType;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "directAccessedEntityType", typeof(global::System.String), attribDirectAccessedEntityType);
					}
				}
			}
			// ReverseAccessedEntityType
			if (!serializationContext.Result.Failed)
			{
				string attribReverseAccessedEntityType = reader.GetAttribute("reverseAccessedEntityType");
				if (attribReverseAccessedEntityType != null)
				{
					global::System.String valueOfReverseAccessedEntityType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribReverseAccessedEntityType), out valueOfReverseAccessedEntityType))
					{
						instanceOfSelfRelation.ReverseAccessedEntityType = valueOfReverseAccessedEntityType;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "reverseAccessedEntityType", typeof(global::System.String), attribReverseAccessedEntityType);
					}
				}
			}
			// Name
			if (!serializationContext.Result.Failed)
			{
				string attribName = reader.GetAttribute("name");
				if (attribName != null)
				{
					global::System.String valueOfName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribName), out valueOfName))
					{
						instanceOfSelfRelation.Name = valueOfName;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "name", typeof(global::System.String), attribName);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory SelfRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of SelfRelation based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized SelfRelation, a new SelfRelation instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created SelfRelation instance, or null if the reader is not pointing to a serialized SelfRelation instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "SelfRelation" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "SelfRelation".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						SelfRelationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as SelfRelationSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of SelfRelation based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of SelfRelation.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new SelfRelation instance should be created.</param>	
		/// <returns>Created SelfRelation instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new SelfRelation(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from SelfRelation, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from SelfRelation.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(SelfRelation.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including SelfRelation itself) instance of SelfRelation based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "SelfRelation" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "SelfRelation".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						SelfRelationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as SelfRelationSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of SelfRelation based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from SelfRelation, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from SelfRelation.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(SelfRelation.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized SelfRelation instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">SelfRelation instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the SelfRelation instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the SelfRelation instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of SelfRelation cannot be monikerized.
			DesignerSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "SelfRelation");
		}
		
		/// <summary>
		/// Public Write() method that serializes one SelfRelation instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">SelfRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">SelfRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			SelfRelation instanceOfSelfRelation = element as SelfRelation;
			global::System.Diagnostics.Debug.Assert(instanceOfSelfRelation != null, "Expecting an instance of SelfRelation");
	
			// DirectAccessor
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfSelfRelation.DirectAccessor;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("directAccessor", propValue);
				}
			}
			// DirectCascadeDelete
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfSelfRelation.DirectCascadeDelete;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("directCascadeDelete", serializedPropValue);
					}
				}
			}
			// DirectFieldName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfSelfRelation.DirectFieldName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("directFieldName", propValue);
				}
			}
			// Disabled
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfSelfRelation.Disabled;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("disabled", serializedPropValue);
					}
				}
			}
			// ReverseAccessor
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfSelfRelation.ReverseAccessor;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("reverseAccessor", propValue);
				}
			}
			// ReverseCascadeDelete
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfSelfRelation.ReverseCascadeDelete;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("reverseCascadeDelete", serializedPropValue);
					}
				}
			}
			// ReverseFieldName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfSelfRelation.ReverseFieldName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("reverseFieldName", propValue);
				}
			}
			// Table
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfSelfRelation.Table;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("table", propValue);
				}
			}
			// UnderlyingEntity
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfSelfRelation.UnderlyingEntity;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("underlyingEntity", propValue);
				}
			}
			// DirectAccessedEntityType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfSelfRelation.DirectAccessedEntityType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("directAccessedEntityType", propValue);
				}
			}
			// ReverseAccessedEntityType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfSelfRelation.ReverseAccessedEntityType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("reverseAccessedEntityType", propValue);
				}
			}
			// Name
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfSelfRelation.Name;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("name", propValue);
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">SelfRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given SelfRelation instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">SelfRelation instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the SelfRelation instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			SelfRelation instance = element as SelfRelation;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of SelfRelation!");
	
			DslModeling::ModelElement container = instance.Entity;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">SelfRelation instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			SelfRelation instance = element as SelfRelation;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of SelfRelation!");
			DslModeling::ModelElement container = instance.Entity;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Worm.Designer
{
	/// <summary>
	/// Serializer WormTypeSerializer for DomainClass WormType.
	/// </summary>
	public partial class WormTypeSerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// WormTypeSerializer Constructor
		/// </summary>
		public WormTypeSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of WormType.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"wormType"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one WormType instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the WormType element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormType instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormType instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			WormType instanceOfWormType = element as WormType;
			global::System.Diagnostics.Debug.Assert(instanceOfWormType != null, "Expecting an instance of WormType");
	
			// Name
			if (!serializationContext.Result.Failed)
			{
				string attribName = reader.GetAttribute("name");
				if (attribName != null)
				{
					global::System.String valueOfName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribName), out valueOfName))
					{
						instanceOfWormType.Name = valueOfName;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "name", typeof(global::System.String), attribName);
					}
				}
			}
			// IdProperty
			if (!serializationContext.Result.Failed)
			{
				string attribIdProperty = reader.GetAttribute("idProperty");
				if (attribIdProperty != null)
				{
					global::System.String valueOfIdProperty;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribIdProperty), out valueOfIdProperty))
					{
						instanceOfWormType.IdProperty = valueOfIdProperty;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "idProperty", typeof(global::System.String), attribIdProperty);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormType instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			WormType instanceOfWormType = element as WormType;
			global::System.Diagnostics.Debug.Assert(instanceOfWormType != null, "Expecting an instance of WormType!");
	
			// Read child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				ReadChildElements(serializationContext, instanceOfWormType, reader);
		}
	
		/// <summary>
		/// This method deserializes all child model elements.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element to deserialized.
		/// This method will read as many child elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
		///    open tag of the unknown element. This implies the if the first child XML element is unknown, this method 
		///    should return immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="element">In-memory WormType instance that will get the deserialized data.</param>
		private static void ReadChildElements(DslModeling::SerializationContext serializationContext, WormType element, global::System.Xml.XmlReader reader)
		{
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				if (string.Compare(reader.LocalName, "entities", global::System.StringComparison.CurrentCulture) == 0)
				{
					if (reader.IsEmptyElement)
					{	// No instance of this relationship, just skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
					else
					{
						DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <entities>
						ReadWormTypeReferencesEntitiesInstances(serializationContext, element, reader);
						DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </entities>
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship WormTypeReferencesEntities.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormType instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
		private static void ReadWormTypeReferencesEntitiesInstances(DslModeling::SerializationContext serializationContext, WormType element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newEntityMonikerOfWormTypeReferencesEntitiesSerializer = serializationContext.Directory.GetSerializer(Entity.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newEntityMonikerOfWormTypeReferencesEntitiesSerializer != null, "Cannot find serializer for Entity!");
				DslModeling::Moniker newEntityMonikerOfWormTypeReferencesEntities = newEntityMonikerOfWormTypeReferencesEntitiesSerializer.TryCreateMonikerInstance(serializationContext, reader, element, WormTypeReferencesEntities.DomainClassId, element.Partition);
				if (newEntityMonikerOfWormTypeReferencesEntities != null)
				{
					new WormTypeReferencesEntities(element.Partition, new DslModeling::RoleAssignment(WormTypeReferencesEntities.WormTypeDomainRoleId, element), new DslModeling::RoleAssignment(WormTypeReferencesEntities.EntityDomainRoleId, newEntityMonikerOfWormTypeReferencesEntities));
					DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
				}
				else
				{
					global::System.Type typeofWormTypeReferencesEntities = typeof(WormTypeReferencesEntities);
					DslModeling::DomainRelationshipXmlSerializer newWormTypeReferencesEntitiesSerializer = serializationContext.Directory.GetSerializer(WormTypeReferencesEntities.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newWormTypeReferencesEntitiesSerializer != null, "Cannot find serializer for WormTypeReferencesEntities!");
					WormTypeReferencesEntities newWormTypeReferencesEntities = newWormTypeReferencesEntitiesSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as WormTypeReferencesEntities;
					if (newWormTypeReferencesEntities != null)
					{
						if (newWormTypeReferencesEntities.GetType() == typeofWormTypeReferencesEntities)
						{	// The relationship should be serialized in short-form.
							DesignerSerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(WormTypeReferencesEntities));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newWormTypeReferencesEntities, WormTypeReferencesEntities.WormTypeDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newWormTypeReferencesEntities.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newWormTypeReferencesEntities.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newWormTypeReferencesEntities, reader);
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of WormType based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized WormType, a new WormType instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created WormType instance, or null if the reader is not pointing to a serialized WormType instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "WormType" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "WormType".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						WormTypeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as WormTypeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of WormType based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of WormType.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new WormType instance should be created.</param>	
		/// <returns>Created WormType instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new WormType(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from WormType, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from WormType.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(WormType.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including WormType itself) instance of WormType based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "WormType" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "WormType".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						WormTypeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as WormTypeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of WormType based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from WormType, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from WormType.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(WormType.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized WormType instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormType instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the WormType instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the WormType instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of WormType cannot be monikerized.
			DesignerSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "WormType");
		}
		
		/// <summary>
		/// Public Write() method that serializes one WormType instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormType instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormType instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			WormType instanceOfWormType = element as WormType;
			global::System.Diagnostics.Debug.Assert(instanceOfWormType != null, "Expecting an instance of WormType");
	
			// Name
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfWormType.Name;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("name", propValue);
				}
			}
			// IdProperty
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfWormType.IdProperty;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("idProperty", propValue);
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormType instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			WormType instance = element as WormType;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of WormType!");
	
			// Write child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed)
				WriteChildElements(serializationContext, instance, writer);
		}
	
		/// <summary>
		/// Serialize all child model elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormType instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		private static void WriteChildElements(DslModeling::SerializationContext serializationContext, WormType element, global::System.Xml.XmlWriter writer)
		{
			// WormTypeReferencesEntities
			global::System.Collections.ObjectModel.ReadOnlyCollection<WormTypeReferencesEntities> allWormTypeReferencesEntitiesInstances = WormTypeReferencesEntities.GetLinksToEntities(element);
			if (!serializationContext.Result.Failed && allWormTypeReferencesEntitiesInstances.Count > 0)
			{
				DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(WormTypeReferencesEntities.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
				global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for WormTypeReferencesEntities!");
	
				writer.WriteStartElement("entities");
				global::System.Type typeofWormTypeReferencesEntities = typeof(WormTypeReferencesEntities);
				foreach (WormTypeReferencesEntities eachWormTypeReferencesEntitiesInstance in allWormTypeReferencesEntitiesInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					if (eachWormTypeReferencesEntitiesInstance.GetType() != typeofWormTypeReferencesEntities)
					{	// Derived relationships will be serialized in full-form.
						DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachWormTypeReferencesEntitiesInstance.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachWormTypeReferencesEntitiesInstance.GetDomainClass().Name + "!");			
						derivedRelSerializer.Write(serializationContext, eachWormTypeReferencesEntitiesInstance, writer);
					}
					else
					{	// No need to serialize the relationship itself, just serialize the role-player directly.
						DslModeling::ModelElement targetElement = eachWormTypeReferencesEntitiesInstance.Entity;
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
						targetSerializer.WriteMoniker(serializationContext, targetElement, writer, element, relSerializer);
					}
				}
				writer.WriteEndElement();
			}
	
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given WormType instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">WormType instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the WormType instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			WormType instance = element as WormType;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of WormType!");
	
			DslModeling::ModelElement container = instance.WormModel;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">WormType instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			WormType instance = element as WormType;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of WormType!");
			DslModeling::ModelElement container = instance.WormModel;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Worm.Designer
{
	/// <summary>
	/// Serializer WormModelHasEntitiesSerializer for DomainClass WormModelHasEntities.
	/// </summary>
	public partial class WormModelHasEntitiesSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// WormModelHasEntitiesSerializer Constructor
		/// </summary>
		public WormModelHasEntitiesSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of WormModelHasEntities.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"wormModelHasEntities"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one WormModelHasEntities instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the WormModelHasEntities element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormModelHasEntities instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player Entity
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read target role-player Entity.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					DesignerSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "WormModelHasEntities");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method reads the target role player Entity.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormModelHasEntities instance that will link to the target Entity instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player Entity
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(Entity.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for Entity!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, WormModelHasEntities.EntityDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				DesignerSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "WormModelHasEntities");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormModelHasEntities instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormModelHasEntities instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of WormModelHasEntities based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized WormModelHasEntities, a new WormModelHasEntities instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created WormModelHasEntities instance, or null if the reader is not pointing to a serialized WormModelHasEntities instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of WormModelHasEntities based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// WormModelHasEntities type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from WormModelHasEntities, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "WormModelHasEntities" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "WormModelHasEntities".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						WormModelHasEntitiesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as WormModelHasEntitiesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of WormModelHasEntities based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of WormModelHasEntities.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new WormModelHasEntities instance should be created.</param>	
		/// <returns>Created WormModelHasEntities instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new WormModelHasEntities(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (WormModelHasEntities.WormModelDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (WormModelHasEntities.EntityDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from WormModelHasEntities, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from WormModelHasEntities.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(WormModelHasEntities.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including WormModelHasEntities itself) instance of WormModelHasEntities based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "WormModelHasEntities" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "WormModelHasEntities".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						WormModelHasEntitiesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as WormModelHasEntitiesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of WormModelHasEntities based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from WormModelHasEntities, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from WormModelHasEntities.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(WormModelHasEntities.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized WormModelHasEntities instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormModelHasEntities instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the WormModelHasEntities instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the WormModelHasEntities instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of WormModelHasEntities cannot be monikerized.
			DesignerSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "WormModelHasEntities");
		}
		
		/// <summary>
		/// Public Write() method that serializes one WormModelHasEntities instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormModelHasEntities instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormModelHasEntities instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormModelHasEntities instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given WormModelHasEntities instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">WormModelHasEntities instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the WormModelHasEntities instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			WormModelHasEntities instance = element as WormModelHasEntities;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of WormModelHasEntities!");
	
			DslModeling::ModelElement container = instance.WormModel;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">WormModelHasEntities instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			WormModelHasEntities instance = element as WormModelHasEntities;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of WormModelHasEntities!");
			DslModeling::ModelElement container = instance.WormModel;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace Worm.Designer
{
	/// <summary>
	/// Serializer EntityHasPropertiesSerializer for DomainClass EntityHasProperties.
	/// </summary>
	public partial class EntityHasPropertiesSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// EntityHasPropertiesSerializer Constructor
		/// </summary>
		public EntityHasPropertiesSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of EntityHasProperties.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"entityHasProperties"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one EntityHasProperties instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the EntityHasProperties element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory EntityHasProperties instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player Property
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read target role-player Property.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					DesignerSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "EntityHasProperties");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method reads the target role player Property.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory EntityHasProperties instance that will link to the target Property instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player Property
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(Property.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for Property!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, EntityHasProperties.PropertyDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				DesignerSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "EntityHasProperties");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory EntityHasProperties instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory EntityHasProperties instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of EntityHasProperties based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized EntityHasProperties, a new EntityHasProperties instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created EntityHasProperties instance, or null if the reader is not pointing to a serialized EntityHasProperties instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of EntityHasProperties based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// EntityHasProperties type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from EntityHasProperties, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "EntityHasProperties" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "EntityHasProperties".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						EntityHasPropertiesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EntityHasPropertiesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of EntityHasProperties based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of EntityHasProperties.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new EntityHasProperties instance should be created.</param>	
		/// <returns>Created EntityHasProperties instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new EntityHasProperties(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (EntityHasProperties.EntityDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (EntityHasProperties.PropertyDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from EntityHasProperties, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from EntityHasProperties.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(EntityHasProperties.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including EntityHasProperties itself) instance of EntityHasProperties based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "EntityHasProperties" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "EntityHasProperties".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						EntityHasPropertiesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EntityHasPropertiesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of EntityHasProperties based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from EntityHasProperties, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from EntityHasProperties.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(EntityHasProperties.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized EntityHasProperties instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EntityHasProperties instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the EntityHasProperties instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the EntityHasProperties instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of EntityHasProperties cannot be monikerized.
			DesignerSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "EntityHasProperties");
		}
		
		/// <summary>
		/// Public Write() method that serializes one EntityHasProperties instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EntityHasProperties instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EntityHasProperties instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EntityHasProperties instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given EntityHasProperties instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">EntityHasProperties instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the EntityHasProperties instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			EntityHasProperties instance = element as EntityHasProperties;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of EntityHasProperties!");
	
			DslModeling::ModelElement container = instance.Entity;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">EntityHasProperties instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			EntityHasProperties instance = element as EntityHasProperties;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of EntityHasProperties!");
			DslModeling::ModelElement container = instance.Entity;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace Worm.Designer
{
	/// <summary>
	/// Serializer EntityReferencesTargetEntitiesSerializer for DomainClass EntityReferencesTargetEntities.
	/// </summary>
	public partial class EntityReferencesTargetEntitiesSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// EntityReferencesTargetEntitiesSerializer Constructor
		/// </summary>
		public EntityReferencesTargetEntitiesSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of EntityReferencesTargetEntities.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"entityReferencesTargetEntities"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one EntityReferencesTargetEntities instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the EntityReferencesTargetEntities element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory EntityReferencesTargetEntities instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements, which include at least the monikerized instance of target role-player TargetEntity
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read target role-player TargetEntity.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					DesignerSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "EntityReferencesTargetEntities");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method reads the target role player TargetEntity.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory EntityReferencesTargetEntities instance that will link to the target Entity instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the monikerized instance of target role-player TargetEntity
			DslModeling::Moniker targetRoleMoniker = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(Entity.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for Entity!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((EntityReferencesTargetEntities)element).SourceEntity, EntityReferencesTargetEntities.DomainClassId, element.Partition);
				if (targetRoleMoniker != null)
				{
					// Attach the target role-player moniker.
					DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, EntityReferencesTargetEntities.TargetEntityDomainRoleId, targetRoleMoniker);
					// Moniker tag has no child XML elements in it, so just skip to the next element.
					DslModeling::SerializationUtilities.Skip(reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRoleMoniker == null)
			{
				DesignerSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "EntityReferencesTargetEntities");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory EntityReferencesTargetEntities instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			EntityReferencesTargetEntities instanceOfEntityReferencesTargetEntities = element as EntityReferencesTargetEntities;
			global::System.Diagnostics.Debug.Assert(instanceOfEntityReferencesTargetEntities != null, "Expecting an instance of EntityReferencesTargetEntities");
	
			// UnderlyingEntity
			if (!serializationContext.Result.Failed)
			{
				string attribUnderlyingEntity = reader.GetAttribute("underlyingEntity");
				if (attribUnderlyingEntity != null)
				{
					global::System.String valueOfUnderlyingEntity;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribUnderlyingEntity), out valueOfUnderlyingEntity))
					{
						instanceOfEntityReferencesTargetEntities.UnderlyingEntity = valueOfUnderlyingEntity;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "underlyingEntity", typeof(global::System.String), attribUnderlyingEntity);
					}
				}
			}
			// LeftCascadeDelete
			if (!serializationContext.Result.Failed)
			{
				string attribLeftCascadeDelete = reader.GetAttribute("leftCascadeDelete");
				if (attribLeftCascadeDelete != null)
				{
					global::System.Boolean valueOfLeftCascadeDelete;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribLeftCascadeDelete), out valueOfLeftCascadeDelete))
					{
						instanceOfEntityReferencesTargetEntities.LeftCascadeDelete = valueOfLeftCascadeDelete;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "leftCascadeDelete", typeof(global::System.Boolean), attribLeftCascadeDelete);
					}
				}
			}
			// LeftFieldName
			if (!serializationContext.Result.Failed)
			{
				string attribLeftFieldName = reader.GetAttribute("leftFieldName");
				if (attribLeftFieldName != null)
				{
					global::System.String valueOfLeftFieldName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribLeftFieldName), out valueOfLeftFieldName))
					{
						instanceOfEntityReferencesTargetEntities.LeftFieldName = valueOfLeftFieldName;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "leftFieldName", typeof(global::System.String), attribLeftFieldName);
					}
				}
			}
			// LeftAccessorName
			if (!serializationContext.Result.Failed)
			{
				string attribLeftAccessorName = reader.GetAttribute("leftAccessorName");
				if (attribLeftAccessorName != null)
				{
					global::System.String valueOfLeftAccessorName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribLeftAccessorName), out valueOfLeftAccessorName))
					{
						instanceOfEntityReferencesTargetEntities.LeftAccessorName = valueOfLeftAccessorName;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "leftAccessorName", typeof(global::System.String), attribLeftAccessorName);
					}
				}
			}
			// Disabled
			if (!serializationContext.Result.Failed)
			{
				string attribDisabled = reader.GetAttribute("disabled");
				if (attribDisabled != null)
				{
					global::System.Boolean valueOfDisabled;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribDisabled), out valueOfDisabled))
					{
						instanceOfEntityReferencesTargetEntities.Disabled = valueOfDisabled;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "disabled", typeof(global::System.Boolean), attribDisabled);
					}
				}
			}
			// Table
			if (!serializationContext.Result.Failed)
			{
				string attribTable = reader.GetAttribute("table");
				if (attribTable != null)
				{
					global::System.String valueOfTable;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTable), out valueOfTable))
					{
						instanceOfEntityReferencesTargetEntities.Table = valueOfTable;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "table", typeof(global::System.String), attribTable);
					}
				}
			}
			// LeftEntity
			if (!serializationContext.Result.Failed)
			{
				string attribLeftEntity = reader.GetAttribute("leftEntity");
				if (attribLeftEntity != null)
				{
					global::System.String valueOfLeftEntity;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribLeftEntity), out valueOfLeftEntity))
					{
						instanceOfEntityReferencesTargetEntities.LeftEntity = valueOfLeftEntity;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "leftEntity", typeof(global::System.String), attribLeftEntity);
					}
				}
			}
			// LeftAccessedEntityType
			if (!serializationContext.Result.Failed)
			{
				string attribLeftAccessedEntityType = reader.GetAttribute("leftAccessedEntityType");
				if (attribLeftAccessedEntityType != null)
				{
					global::System.String valueOfLeftAccessedEntityType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribLeftAccessedEntityType), out valueOfLeftAccessedEntityType))
					{
						instanceOfEntityReferencesTargetEntities.LeftAccessedEntityType = valueOfLeftAccessedEntityType;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "leftAccessedEntityType", typeof(global::System.String), attribLeftAccessedEntityType);
					}
				}
			}
			// RightAccessedEntityType
			if (!serializationContext.Result.Failed)
			{
				string attribRightAccessedEntityType = reader.GetAttribute("rightAccessedEntityType");
				if (attribRightAccessedEntityType != null)
				{
					global::System.String valueOfRightAccessedEntityType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribRightAccessedEntityType), out valueOfRightAccessedEntityType))
					{
						instanceOfEntityReferencesTargetEntities.RightAccessedEntityType = valueOfRightAccessedEntityType;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "rightAccessedEntityType", typeof(global::System.String), attribRightAccessedEntityType);
					}
				}
			}
			// RightFieldName
			if (!serializationContext.Result.Failed)
			{
				string attribRightFieldName = reader.GetAttribute("rightFieldName");
				if (attribRightFieldName != null)
				{
					global::System.String valueOfRightFieldName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribRightFieldName), out valueOfRightFieldName))
					{
						instanceOfEntityReferencesTargetEntities.RightFieldName = valueOfRightFieldName;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "rightFieldName", typeof(global::System.String), attribRightFieldName);
					}
				}
			}
			// RightCascadeDelete
			if (!serializationContext.Result.Failed)
			{
				string attribRightCascadeDelete = reader.GetAttribute("rightCascadeDelete");
				if (attribRightCascadeDelete != null)
				{
					global::System.Boolean valueOfRightCascadeDelete;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribRightCascadeDelete), out valueOfRightCascadeDelete))
					{
						instanceOfEntityReferencesTargetEntities.RightCascadeDelete = valueOfRightCascadeDelete;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "rightCascadeDelete", typeof(global::System.Boolean), attribRightCascadeDelete);
					}
				}
			}
			// RightAccessorName
			if (!serializationContext.Result.Failed)
			{
				string attribRightAccessorName = reader.GetAttribute("rightAccessorName");
				if (attribRightAccessorName != null)
				{
					global::System.String valueOfRightAccessorName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribRightAccessorName), out valueOfRightAccessorName))
					{
						instanceOfEntityReferencesTargetEntities.RightAccessorName = valueOfRightAccessorName;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "rightAccessorName", typeof(global::System.String), attribRightAccessorName);
					}
				}
			}
			// RightEntity
			if (!serializationContext.Result.Failed)
			{
				string attribRightEntity = reader.GetAttribute("rightEntity");
				if (attribRightEntity != null)
				{
					global::System.String valueOfRightEntity;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribRightEntity), out valueOfRightEntity))
					{
						instanceOfEntityReferencesTargetEntities.RightEntity = valueOfRightEntity;
					}
					else
					{	// Invalid property value, ignored.
						DesignerSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "rightEntity", typeof(global::System.String), attribRightEntity);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory EntityReferencesTargetEntities instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of EntityReferencesTargetEntities based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized EntityReferencesTargetEntities, a new EntityReferencesTargetEntities instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created EntityReferencesTargetEntities instance, or null if the reader is not pointing to a serialized EntityReferencesTargetEntities instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of EntityReferencesTargetEntities based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// EntityReferencesTargetEntities type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from EntityReferencesTargetEntities, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "EntityReferencesTargetEntities" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "EntityReferencesTargetEntities".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						EntityReferencesTargetEntitiesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EntityReferencesTargetEntitiesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of EntityReferencesTargetEntities based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of EntityReferencesTargetEntities.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new EntityReferencesTargetEntities instance should be created.</param>	
		/// <returns>Created EntityReferencesTargetEntities instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new EntityReferencesTargetEntities(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (EntityReferencesTargetEntities.SourceEntityDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (EntityReferencesTargetEntities.TargetEntityDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from EntityReferencesTargetEntities, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from EntityReferencesTargetEntities.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(EntityReferencesTargetEntities.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including EntityReferencesTargetEntities itself) instance of EntityReferencesTargetEntities based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "EntityReferencesTargetEntities" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "EntityReferencesTargetEntities".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						EntityReferencesTargetEntitiesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EntityReferencesTargetEntitiesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of EntityReferencesTargetEntities based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from EntityReferencesTargetEntities, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from EntityReferencesTargetEntities.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(EntityReferencesTargetEntities.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized EntityReferencesTargetEntities instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EntityReferencesTargetEntities instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the EntityReferencesTargetEntities instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the EntityReferencesTargetEntities instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of EntityReferencesTargetEntities cannot be monikerized.
			DesignerSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "EntityReferencesTargetEntities");
		}
		
		/// <summary>
		/// Public Write() method that serializes one EntityReferencesTargetEntities instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EntityReferencesTargetEntities instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write the target role-player instance.
			EntityReferencesTargetEntities instance = element as EntityReferencesTargetEntities;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of EntityReferencesTargetEntities!");
	
			DslModeling::ModelElement targetElement = instance.TargetEntity;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.WriteMoniker(serializationContext, targetElement, writer, instance.SourceEntity, this);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EntityReferencesTargetEntities instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			EntityReferencesTargetEntities instanceOfEntityReferencesTargetEntities = element as EntityReferencesTargetEntities;
			global::System.Diagnostics.Debug.Assert(instanceOfEntityReferencesTargetEntities != null, "Expecting an instance of EntityReferencesTargetEntities");
	
			// UnderlyingEntity
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfEntityReferencesTargetEntities.UnderlyingEntity;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("underlyingEntity", propValue);
				}
			}
			// LeftCascadeDelete
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfEntityReferencesTargetEntities.LeftCascadeDelete;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("leftCascadeDelete", serializedPropValue);
					}
				}
			}
			// LeftFieldName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfEntityReferencesTargetEntities.LeftFieldName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("leftFieldName", propValue);
				}
			}
			// LeftAccessorName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfEntityReferencesTargetEntities.LeftAccessorName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("leftAccessorName", propValue);
				}
			}
			// Disabled
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfEntityReferencesTargetEntities.Disabled;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("disabled", serializedPropValue);
					}
				}
			}
			// Table
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfEntityReferencesTargetEntities.Table;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("table", propValue);
				}
			}
			// LeftEntity
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfEntityReferencesTargetEntities.LeftEntity;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("leftEntity", propValue);
				}
			}
			// LeftAccessedEntityType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfEntityReferencesTargetEntities.LeftAccessedEntityType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("leftAccessedEntityType", propValue);
				}
			}
			// RightAccessedEntityType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfEntityReferencesTargetEntities.RightAccessedEntityType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("rightAccessedEntityType", propValue);
				}
			}
			// RightFieldName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfEntityReferencesTargetEntities.RightFieldName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("rightFieldName", propValue);
				}
			}
			// RightCascadeDelete
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfEntityReferencesTargetEntities.RightCascadeDelete;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("rightCascadeDelete", serializedPropValue);
					}
				}
			}
			// RightAccessorName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfEntityReferencesTargetEntities.RightAccessorName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("rightAccessorName", propValue);
				}
			}
			// RightEntity
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfEntityReferencesTargetEntities.RightEntity;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("rightEntity", propValue);
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EntityReferencesTargetEntities instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given EntityReferencesTargetEntities instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">EntityReferencesTargetEntities instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the EntityReferencesTargetEntities instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			EntityReferencesTargetEntities instance = element as EntityReferencesTargetEntities;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of EntityReferencesTargetEntities!");
	
			DslModeling::ModelElement container = instance.SourceEntity;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">EntityReferencesTargetEntities instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			EntityReferencesTargetEntities instance = element as EntityReferencesTargetEntities;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of EntityReferencesTargetEntities!");
			DslModeling::ModelElement container = instance.SourceEntity;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a Entity
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of Entity that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of Entity</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of Entity instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is Entity, "Expecting an instance of Entity!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, EntityReferencesTargetEntities.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), EntityReferencesTargetEntities.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a Entity.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is Entity, "Expecting an instance of Entity!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is Entity, "Expecting an instance of Entity!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace Worm.Designer
{
	/// <summary>
	/// Serializer EntityHasSupressedPropertiesSerializer for DomainClass EntityHasSupressedProperties.
	/// </summary>
	public partial class EntityHasSupressedPropertiesSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// EntityHasSupressedPropertiesSerializer Constructor
		/// </summary>
		public EntityHasSupressedPropertiesSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of EntityHasSupressedProperties.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"entityHasSupressedProperties"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one EntityHasSupressedProperties instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the EntityHasSupressedProperties element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory EntityHasSupressedProperties instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player SupressedProperty
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read target role-player SupressedProperty.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					DesignerSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "EntityHasSupressedProperties");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method reads the target role player SupressedProperty.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory EntityHasSupressedProperties instance that will link to the target SupressedProperty instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player SupressedProperty
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(SupressedProperty.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for SupressedProperty!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, EntityHasSupressedProperties.SupressedPropertyDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				DesignerSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "EntityHasSupressedProperties");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory EntityHasSupressedProperties instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory EntityHasSupressedProperties instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of EntityHasSupressedProperties based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized EntityHasSupressedProperties, a new EntityHasSupressedProperties instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created EntityHasSupressedProperties instance, or null if the reader is not pointing to a serialized EntityHasSupressedProperties instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of EntityHasSupressedProperties based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// EntityHasSupressedProperties type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from EntityHasSupressedProperties, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "EntityHasSupressedProperties" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "EntityHasSupressedProperties".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						EntityHasSupressedPropertiesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EntityHasSupressedPropertiesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of EntityHasSupressedProperties based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of EntityHasSupressedProperties.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new EntityHasSupressedProperties instance should be created.</param>	
		/// <returns>Created EntityHasSupressedProperties instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new EntityHasSupressedProperties(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (EntityHasSupressedProperties.EntityDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (EntityHasSupressedProperties.SupressedPropertyDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from EntityHasSupressedProperties, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from EntityHasSupressedProperties.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(EntityHasSupressedProperties.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including EntityHasSupressedProperties itself) instance of EntityHasSupressedProperties based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "EntityHasSupressedProperties" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "EntityHasSupressedProperties".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						EntityHasSupressedPropertiesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EntityHasSupressedPropertiesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of EntityHasSupressedProperties based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from EntityHasSupressedProperties, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from EntityHasSupressedProperties.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(EntityHasSupressedProperties.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized EntityHasSupressedProperties instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EntityHasSupressedProperties instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the EntityHasSupressedProperties instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the EntityHasSupressedProperties instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of EntityHasSupressedProperties cannot be monikerized.
			DesignerSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "EntityHasSupressedProperties");
		}
		
		/// <summary>
		/// Public Write() method that serializes one EntityHasSupressedProperties instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EntityHasSupressedProperties instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EntityHasSupressedProperties instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EntityHasSupressedProperties instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given EntityHasSupressedProperties instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">EntityHasSupressedProperties instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the EntityHasSupressedProperties instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			EntityHasSupressedProperties instance = element as EntityHasSupressedProperties;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of EntityHasSupressedProperties!");
	
			DslModeling::ModelElement container = instance.Entity;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">EntityHasSupressedProperties instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			EntityHasSupressedProperties instance = element as EntityHasSupressedProperties;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of EntityHasSupressedProperties!");
			DslModeling::ModelElement container = instance.Entity;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace Worm.Designer
{
	/// <summary>
	/// Serializer EntityHasSelfRelationsSerializer for DomainClass EntityHasSelfRelations.
	/// </summary>
	public partial class EntityHasSelfRelationsSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// EntityHasSelfRelationsSerializer Constructor
		/// </summary>
		public EntityHasSelfRelationsSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of EntityHasSelfRelations.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"entityHasSelfRelations"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one EntityHasSelfRelations instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the EntityHasSelfRelations element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory EntityHasSelfRelations instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player SelfRelation
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read target role-player SelfRelation.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					DesignerSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "EntityHasSelfRelations");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method reads the target role player SelfRelation.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory EntityHasSelfRelations instance that will link to the target SelfRelation instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player SelfRelation
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(SelfRelation.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for SelfRelation!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, EntityHasSelfRelations.SelfRelationDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				DesignerSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "EntityHasSelfRelations");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory EntityHasSelfRelations instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory EntityHasSelfRelations instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of EntityHasSelfRelations based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized EntityHasSelfRelations, a new EntityHasSelfRelations instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created EntityHasSelfRelations instance, or null if the reader is not pointing to a serialized EntityHasSelfRelations instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of EntityHasSelfRelations based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// EntityHasSelfRelations type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from EntityHasSelfRelations, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "EntityHasSelfRelations" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "EntityHasSelfRelations".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						EntityHasSelfRelationsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EntityHasSelfRelationsSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of EntityHasSelfRelations based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of EntityHasSelfRelations.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new EntityHasSelfRelations instance should be created.</param>	
		/// <returns>Created EntityHasSelfRelations instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new EntityHasSelfRelations(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (EntityHasSelfRelations.EntityDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (EntityHasSelfRelations.SelfRelationDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from EntityHasSelfRelations, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from EntityHasSelfRelations.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(EntityHasSelfRelations.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including EntityHasSelfRelations itself) instance of EntityHasSelfRelations based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "EntityHasSelfRelations" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "EntityHasSelfRelations".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						EntityHasSelfRelationsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EntityHasSelfRelationsSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of EntityHasSelfRelations based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from EntityHasSelfRelations, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from EntityHasSelfRelations.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(EntityHasSelfRelations.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized EntityHasSelfRelations instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EntityHasSelfRelations instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the EntityHasSelfRelations instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the EntityHasSelfRelations instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of EntityHasSelfRelations cannot be monikerized.
			DesignerSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "EntityHasSelfRelations");
		}
		
		/// <summary>
		/// Public Write() method that serializes one EntityHasSelfRelations instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EntityHasSelfRelations instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EntityHasSelfRelations instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EntityHasSelfRelations instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given EntityHasSelfRelations instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">EntityHasSelfRelations instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the EntityHasSelfRelations instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			EntityHasSelfRelations instance = element as EntityHasSelfRelations;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of EntityHasSelfRelations!");
	
			DslModeling::ModelElement container = instance.Entity;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">EntityHasSelfRelations instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			EntityHasSelfRelations instance = element as EntityHasSelfRelations;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of EntityHasSelfRelations!");
			DslModeling::ModelElement container = instance.Entity;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace Worm.Designer
{
	/// <summary>
	/// Serializer WormModelHasTablesSerializer for DomainClass WormModelHasTables.
	/// </summary>
	public partial class WormModelHasTablesSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// WormModelHasTablesSerializer Constructor
		/// </summary>
		public WormModelHasTablesSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of WormModelHasTables.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"wormModelHasTables"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one WormModelHasTables instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the WormModelHasTables element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormModelHasTables instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player Table
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read target role-player Table.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					DesignerSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "WormModelHasTables");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method reads the target role player Table.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormModelHasTables instance that will link to the target Table instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player Table
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(Table.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for Table!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, WormModelHasTables.TableDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				DesignerSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "WormModelHasTables");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormModelHasTables instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormModelHasTables instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of WormModelHasTables based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized WormModelHasTables, a new WormModelHasTables instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created WormModelHasTables instance, or null if the reader is not pointing to a serialized WormModelHasTables instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of WormModelHasTables based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// WormModelHasTables type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from WormModelHasTables, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "WormModelHasTables" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "WormModelHasTables".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						WormModelHasTablesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as WormModelHasTablesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of WormModelHasTables based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of WormModelHasTables.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new WormModelHasTables instance should be created.</param>	
		/// <returns>Created WormModelHasTables instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new WormModelHasTables(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (WormModelHasTables.WormModelDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (WormModelHasTables.TableDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from WormModelHasTables, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from WormModelHasTables.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(WormModelHasTables.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including WormModelHasTables itself) instance of WormModelHasTables based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "WormModelHasTables" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "WormModelHasTables".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						WormModelHasTablesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as WormModelHasTablesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of WormModelHasTables based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from WormModelHasTables, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from WormModelHasTables.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(WormModelHasTables.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized WormModelHasTables instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormModelHasTables instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the WormModelHasTables instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the WormModelHasTables instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of WormModelHasTables cannot be monikerized.
			DesignerSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "WormModelHasTables");
		}
		
		/// <summary>
		/// Public Write() method that serializes one WormModelHasTables instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormModelHasTables instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormModelHasTables instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormModelHasTables instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given WormModelHasTables instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">WormModelHasTables instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the WormModelHasTables instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			WormModelHasTables instance = element as WormModelHasTables;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of WormModelHasTables!");
	
			DslModeling::ModelElement container = instance.WormModel;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">WormModelHasTables instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			WormModelHasTables instance = element as WormModelHasTables;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of WormModelHasTables!");
			DslModeling::ModelElement container = instance.WormModel;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace Worm.Designer
{
	/// <summary>
	/// Serializer TableReferencesEntitySerializer for DomainClass TableReferencesEntity.
	/// </summary>
	public partial class TableReferencesEntitySerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// TableReferencesEntitySerializer Constructor
		/// </summary>
		public TableReferencesEntitySerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of TableReferencesEntity.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"tableReferencesEntity"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one TableReferencesEntity instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the TableReferencesEntity element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TableReferencesEntity instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the monikerized instance of target role-player Entity
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read target role-player Entity.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					DesignerSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "TableReferencesEntity");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method reads the target role player Entity.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TableReferencesEntity instance that will link to the target Entity instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the monikerized instance of target role-player Entity
			DslModeling::Moniker targetRoleMoniker = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(Entity.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for Entity!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((TableReferencesEntity)element).Table, TableReferencesEntity.DomainClassId, element.Partition);
				if (targetRoleMoniker != null)
				{
					// Attach the target role-player moniker.
					DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, TableReferencesEntity.EntityDomainRoleId, targetRoleMoniker);
					// Moniker tag has no child XML elements in it, so just skip to the next element.
					DslModeling::SerializationUtilities.Skip(reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRoleMoniker == null)
			{
				DesignerSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "TableReferencesEntity");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TableReferencesEntity instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TableReferencesEntity instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of TableReferencesEntity based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized TableReferencesEntity, a new TableReferencesEntity instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created TableReferencesEntity instance, or null if the reader is not pointing to a serialized TableReferencesEntity instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of TableReferencesEntity based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// TableReferencesEntity type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from TableReferencesEntity, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "TableReferencesEntity" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "TableReferencesEntity".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						TableReferencesEntitySerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TableReferencesEntitySerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of TableReferencesEntity based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of TableReferencesEntity.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new TableReferencesEntity instance should be created.</param>	
		/// <returns>Created TableReferencesEntity instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new TableReferencesEntity(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (TableReferencesEntity.TableDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (TableReferencesEntity.EntityDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from TableReferencesEntity, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from TableReferencesEntity.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(TableReferencesEntity.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including TableReferencesEntity itself) instance of TableReferencesEntity based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "TableReferencesEntity" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "TableReferencesEntity".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						TableReferencesEntitySerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TableReferencesEntitySerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of TableReferencesEntity based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from TableReferencesEntity, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from TableReferencesEntity.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(TableReferencesEntity.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized TableReferencesEntity instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TableReferencesEntity instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the TableReferencesEntity instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the TableReferencesEntity instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of TableReferencesEntity cannot be monikerized.
			DesignerSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "TableReferencesEntity");
		}
		
		/// <summary>
		/// Public Write() method that serializes one TableReferencesEntity instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TableReferencesEntity instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TableReferencesEntity instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TableReferencesEntity instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given TableReferencesEntity instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">TableReferencesEntity instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the TableReferencesEntity instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			TableReferencesEntity instance = element as TableReferencesEntity;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of TableReferencesEntity!");
	
			DslModeling::ModelElement container = instance.Table;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">TableReferencesEntity instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			TableReferencesEntity instance = element as TableReferencesEntity;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of TableReferencesEntity!");
			DslModeling::ModelElement container = instance.Table;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a Entity
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of Table that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of Entity</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of Entity instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is Table, "Expecting an instance of Table!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, TableReferencesEntity.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), TableReferencesEntity.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a Entity.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is Table, "Expecting an instance of Table!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is Entity, "Expecting an instance of Entity!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace Worm.Designer
{
	/// <summary>
	/// Serializer WormModelHasTypesSerializer for DomainClass WormModelHasTypes.
	/// </summary>
	public partial class WormModelHasTypesSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// WormModelHasTypesSerializer Constructor
		/// </summary>
		public WormModelHasTypesSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of WormModelHasTypes.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"wormModelHasTypes"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one WormModelHasTypes instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the WormModelHasTypes element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormModelHasTypes instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player WormType
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read target role-player WormType.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					DesignerSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "WormModelHasTypes");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method reads the target role player WormType.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormModelHasTypes instance that will link to the target WormType instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player WormType
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(WormType.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for WormType!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, WormModelHasTypes.WormTypeDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				DesignerSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "WormModelHasTypes");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormModelHasTypes instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormModelHasTypes instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of WormModelHasTypes based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized WormModelHasTypes, a new WormModelHasTypes instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created WormModelHasTypes instance, or null if the reader is not pointing to a serialized WormModelHasTypes instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of WormModelHasTypes based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// WormModelHasTypes type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from WormModelHasTypes, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "WormModelHasTypes" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "WormModelHasTypes".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						WormModelHasTypesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as WormModelHasTypesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of WormModelHasTypes based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of WormModelHasTypes.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new WormModelHasTypes instance should be created.</param>	
		/// <returns>Created WormModelHasTypes instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new WormModelHasTypes(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (WormModelHasTypes.WormModelDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (WormModelHasTypes.WormTypeDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from WormModelHasTypes, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from WormModelHasTypes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(WormModelHasTypes.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including WormModelHasTypes itself) instance of WormModelHasTypes based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "WormModelHasTypes" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "WormModelHasTypes".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						WormModelHasTypesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as WormModelHasTypesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of WormModelHasTypes based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from WormModelHasTypes, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from WormModelHasTypes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(WormModelHasTypes.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized WormModelHasTypes instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormModelHasTypes instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the WormModelHasTypes instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the WormModelHasTypes instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of WormModelHasTypes cannot be monikerized.
			DesignerSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "WormModelHasTypes");
		}
		
		/// <summary>
		/// Public Write() method that serializes one WormModelHasTypes instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormModelHasTypes instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormModelHasTypes instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormModelHasTypes instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given WormModelHasTypes instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">WormModelHasTypes instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the WormModelHasTypes instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			WormModelHasTypes instance = element as WormModelHasTypes;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of WormModelHasTypes!");
	
			DslModeling::ModelElement container = instance.WormModel;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">WormModelHasTypes instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			WormModelHasTypes instance = element as WormModelHasTypes;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of WormModelHasTypes!");
			DslModeling::ModelElement container = instance.WormModel;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace Worm.Designer
{
	/// <summary>
	/// Serializer WormTypeReferencesEntitiesSerializer for DomainClass WormTypeReferencesEntities.
	/// </summary>
	public partial class WormTypeReferencesEntitiesSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// WormTypeReferencesEntitiesSerializer Constructor
		/// </summary>
		public WormTypeReferencesEntitiesSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of WormTypeReferencesEntities.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"wormTypeReferencesEntities"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one WormTypeReferencesEntities instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the WormTypeReferencesEntities element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormTypeReferencesEntities instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the monikerized instance of target role-player Entity
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read target role-player Entity.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					DesignerSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "WormTypeReferencesEntities");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method reads the target role player Entity.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormTypeReferencesEntities instance that will link to the target Entity instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the monikerized instance of target role-player Entity
			DslModeling::Moniker targetRoleMoniker = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(Entity.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for Entity!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((WormTypeReferencesEntities)element).WormType, WormTypeReferencesEntities.DomainClassId, element.Partition);
				if (targetRoleMoniker != null)
				{
					// Attach the target role-player moniker.
					DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, WormTypeReferencesEntities.EntityDomainRoleId, targetRoleMoniker);
					// Moniker tag has no child XML elements in it, so just skip to the next element.
					DslModeling::SerializationUtilities.Skip(reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRoleMoniker == null)
			{
				DesignerSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "WormTypeReferencesEntities");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormTypeReferencesEntities instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory WormTypeReferencesEntities instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of WormTypeReferencesEntities based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized WormTypeReferencesEntities, a new WormTypeReferencesEntities instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created WormTypeReferencesEntities instance, or null if the reader is not pointing to a serialized WormTypeReferencesEntities instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of WormTypeReferencesEntities based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// WormTypeReferencesEntities type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from WormTypeReferencesEntities, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "WormTypeReferencesEntities" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "WormTypeReferencesEntities".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						WormTypeReferencesEntitiesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as WormTypeReferencesEntitiesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of WormTypeReferencesEntities based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of WormTypeReferencesEntities.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new WormTypeReferencesEntities instance should be created.</param>	
		/// <returns>Created WormTypeReferencesEntities instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new WormTypeReferencesEntities(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (WormTypeReferencesEntities.WormTypeDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (WormTypeReferencesEntities.EntityDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from WormTypeReferencesEntities, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from WormTypeReferencesEntities.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(WormTypeReferencesEntities.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including WormTypeReferencesEntities itself) instance of WormTypeReferencesEntities based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "WormTypeReferencesEntities" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "WormTypeReferencesEntities".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						WormTypeReferencesEntitiesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as WormTypeReferencesEntitiesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of WormTypeReferencesEntities based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from WormTypeReferencesEntities, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from WormTypeReferencesEntities.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(WormTypeReferencesEntities.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized WormTypeReferencesEntities instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormTypeReferencesEntities instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the WormTypeReferencesEntities instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the WormTypeReferencesEntities instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of WormTypeReferencesEntities cannot be monikerized.
			DesignerSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "WormTypeReferencesEntities");
		}
		
		/// <summary>
		/// Public Write() method that serializes one WormTypeReferencesEntities instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormTypeReferencesEntities instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormTypeReferencesEntities instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">WormTypeReferencesEntities instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given WormTypeReferencesEntities instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">WormTypeReferencesEntities instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the WormTypeReferencesEntities instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			WormTypeReferencesEntities instance = element as WormTypeReferencesEntities;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of WormTypeReferencesEntities!");
	
			DslModeling::ModelElement container = instance.WormType;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">WormTypeReferencesEntities instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			WormTypeReferencesEntities instance = element as WormTypeReferencesEntities;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of WormTypeReferencesEntities!");
			DslModeling::ModelElement container = instance.WormType;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a Entity
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of WormType that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of Entity</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of Entity instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is WormType, "Expecting an instance of WormType!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, WormTypeReferencesEntities.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), WormTypeReferencesEntities.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a Entity.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is WormType, "Expecting an instance of WormType!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is Entity, "Expecting an instance of Entity!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace Worm.Designer
{
	/// <summary>
	/// Serializer EntityShapeSerializer for DomainClass EntityShape.
	/// </summary>
	public partial class EntityShapeSerializer : DslDiagrams::CompartmentShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// EntityShapeSerializer Constructor
		/// </summary>
		public EntityShapeSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of EntityShape.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"entityShape"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of EntityShape.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"entityShapeMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of EntityShape in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one EntityShape instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the EntityShape element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory EntityShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of EntityShape based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized EntityShape, a new EntityShape instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created EntityShape instance, or null if the reader is not pointing to a serialized EntityShape instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "EntityShape" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "EntityShape".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						EntityShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EntityShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of EntityShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of EntityShape.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new EntityShape instance should be created.</param>	
		/// <returns>Created EntityShape instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DesignerSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new EntityShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DesignerSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DesignerSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DesignerSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from EntityShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from EntityShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(EntityShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including EntityShape itself) instance of EntityShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "EntityShape" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "EntityShape".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						EntityShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EntityShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of EntityShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DslModeling::SerializationUtilities.UnescapeXmlString(reader.GetAttribute(this.MonikerAttributeName));
			if (string.IsNullOrEmpty(monikerString))
			{	
				DesignerSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, EntityShape.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DesignerSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DesignerSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from EntityShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from EntityShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(EntityShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized EntityShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EntityShape instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the EntityShape instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the EntityShape instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			writer.WriteAttributeString(this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one EntityShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EntityShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given EntityShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">EntityShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the EntityShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			EntityShape instance = element as EntityShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of EntityShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">EntityShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace Worm.Designer
{
	/// <summary>
	/// Serializer EntityConnectorSerializer for DomainClass EntityConnector.
	/// </summary>
	public partial class EntityConnectorSerializer : DslDiagrams::BinaryLinkShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// EntityConnectorSerializer Constructor
		/// </summary>
		public EntityConnectorSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of EntityConnector.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"entityConnector"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one EntityConnector instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the EntityConnector element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory EntityConnector instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of EntityConnector based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized EntityConnector, a new EntityConnector instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created EntityConnector instance, or null if the reader is not pointing to a serialized EntityConnector instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "EntityConnector" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "EntityConnector".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						EntityConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EntityConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of EntityConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of EntityConnector.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new EntityConnector instance should be created.</param>	
		/// <returns>Created EntityConnector instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new EntityConnector(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from EntityConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from EntityConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(EntityConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including EntityConnector itself) instance of EntityConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "EntityConnector" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "EntityConnector".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						EntityConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EntityConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of EntityConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from EntityConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from EntityConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(EntityConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized EntityConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EntityConnector instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the EntityConnector instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the EntityConnector instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of EntityConnector cannot be monikerized.
			DesignerSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "EntityConnector");
		}
		
		/// <summary>
		/// Public Write() method that serializes one EntityConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EntityConnector instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given EntityConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">EntityConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the EntityConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			EntityConnector instance = element as EntityConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of EntityConnector!");
	
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">EntityConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			EntityConnector instance = element as EntityConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of EntityConnector!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Worm.Designer
{
	/// <summary>
	/// Serializer DesignerDiagramSerializer for DomainClass DesignerDiagram.
	/// </summary>
	public partial class DesignerDiagramSerializer : DslDiagrams::DiagramSerializer
	{
		#region Constructor
		/// <summary>
		/// DesignerDiagramSerializer Constructor
		/// </summary>
		public DesignerDiagramSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of DesignerDiagram.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"minimalLanguageDiagram"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one DesignerDiagram instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the DesignerDiagram element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DesignerDiagram instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DesignerSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of DesignerDiagram based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized DesignerDiagram, a new DesignerDiagram instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created DesignerDiagram instance, or null if the reader is not pointing to a serialized DesignerDiagram instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "DesignerDiagram" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "DesignerDiagram".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						DesignerDiagramSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as DesignerDiagramSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of DesignerDiagram based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of DesignerDiagram.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new DesignerDiagram instance should be created.</param>	
		/// <returns>Created DesignerDiagram instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new DesignerDiagram(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from DesignerDiagram, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from DesignerDiagram.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(DesignerDiagram.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including DesignerDiagram itself) instance of DesignerDiagram based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "DesignerDiagram" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "DesignerDiagram".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						DesignerDiagramSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as DesignerDiagramSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of DesignerDiagram based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from DesignerDiagram, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from DesignerDiagram.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(DesignerDiagram.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized DesignerDiagram instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DesignerDiagram instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the DesignerDiagram instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the DesignerDiagram instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of DesignerDiagram cannot be monikerized.
			DesignerSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "DesignerDiagram");
		}
		
		/// <summary>
		/// Public Write() method that serializes one DesignerDiagram instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DesignerDiagram instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given DesignerDiagram instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">DesignerDiagram instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the DesignerDiagram instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			DesignerDiagram instance = element as DesignerDiagram;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of DesignerDiagram!");
	
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">DesignerDiagram instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			DesignerDiagram instance = element as DesignerDiagram;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of DesignerDiagram!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Worm.Designer
{
	/// <summary>
	/// A DomainXmlSerializationBehavior implementation for defined behavior DesignerSerializationBehavior.
	/// This is the abstract base of the double-derived implementation.
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
	public abstract class DesignerSerializationBehaviorBase : DslModeling::DomainXmlSerializationBehavior
	{
		#region Member Variables
		/// <summary>
		/// A dictionary that maps DomainClass Id to DomainClassXmlSerializer types.
		/// </summary>
		private static global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerDirectoryEntry> serializerTypes;
		#endregion
	
		#region Constructor
		/// <summary>
		/// Protected constructor to prevent public instantiation.
		/// </summary>
		protected DesignerSerializationBehaviorBase() : base() { }
		#endregion
		
		#region Protected Methods
		/// <summary>
		/// Allows custom serializers to be added.
		/// Base implementation doesn't do anything.
		/// </summary>
		/// <returns>Custom serializer types, null or empty list if there's no custom serializer types.</returns>
		[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
		protected virtual global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerDirectoryEntry> CustomSerializerTypes
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return null; }
		}
		#endregion
	
		#region Public Methods
		/// <summary>
		/// This provides a mapping from DomainClass Id to DomainXmlSerializer implementation types.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable (global::System.Diagnostics.DebuggerBrowsableState.Never)]	// Will trigger creation otherwise.
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		public override global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerDirectoryEntry> AllSerializers
		{
			get
			{
				if (DesignerSerializationBehavior.serializerTypes == null)
				{
					global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerDirectoryEntry> customSerializerTypes = this.CustomSerializerTypes;
					int customSerializerCount = (customSerializerTypes == null ? 0 : customSerializerTypes.Count);
					DesignerSerializationBehavior.serializerTypes = new global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerDirectoryEntry>(19 + customSerializerCount);
	
					#region Serializers defined in this model
					DesignerSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(WormModel.DomainClassId, typeof(WormModelSerializer)));
					DesignerSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(Entity.DomainClassId, typeof(EntitySerializer)));
					DesignerSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(Table.DomainClassId, typeof(TableSerializer)));
					DesignerSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(Property.DomainClassId, typeof(PropertySerializer)));
					DesignerSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(SupressedProperty.DomainClassId, typeof(SupressedPropertySerializer)));
					DesignerSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(SelfRelation.DomainClassId, typeof(SelfRelationSerializer)));
					DesignerSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(WormType.DomainClassId, typeof(WormTypeSerializer)));
					DesignerSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(WormModelHasEntities.DomainClassId, typeof(WormModelHasEntitiesSerializer)));
					DesignerSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(EntityHasProperties.DomainClassId, typeof(EntityHasPropertiesSerializer)));
					DesignerSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(EntityReferencesTargetEntities.DomainClassId, typeof(EntityReferencesTargetEntitiesSerializer)));
					DesignerSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(EntityHasSupressedProperties.DomainClassId, typeof(EntityHasSupressedPropertiesSerializer)));
					DesignerSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(EntityHasSelfRelations.DomainClassId, typeof(EntityHasSelfRelationsSerializer)));
					DesignerSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(WormModelHasTables.DomainClassId, typeof(WormModelHasTablesSerializer)));
					DesignerSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(TableReferencesEntity.DomainClassId, typeof(TableReferencesEntitySerializer)));
					DesignerSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(WormModelHasTypes.DomainClassId, typeof(WormModelHasTypesSerializer)));
					DesignerSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(WormTypeReferencesEntities.DomainClassId, typeof(WormTypeReferencesEntitiesSerializer)));
					DesignerSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(EntityShape.DomainClassId, typeof(EntityShapeSerializer)));
					DesignerSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(EntityConnector.DomainClassId, typeof(EntityConnectorSerializer)));
					DesignerSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(DesignerDiagram.DomainClassId, typeof(DesignerDiagramSerializer)));
					#endregion
					
					// Custom ones
					if (customSerializerCount > 0)
					{
						DesignerSerializationBehavior.serializerTypes.AddRange(customSerializerTypes);
					}
				}
				return DesignerSerializationBehavior.serializerTypes.AsReadOnly();
			}
		}
		#endregion
	}
	
	/// <summary>
	/// A DomainXmlSerializationBehavior implementation for defined behavior DesignerSerializationBehavior.
	/// This is the concrete type of the double-derived implementation.
	/// </summary>
	public sealed partial class DesignerSerializationBehavior : DesignerSerializationBehaviorBase
	{
		#region Singleton Instance
		/// <summary>
		/// Singleton instance.
		/// </summary>
		private static DesignerSerializationBehavior instance;
	
		/// <summary>
		/// Singleton instance.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable (global::System.Diagnostics.DebuggerBrowsableState.Never)]	// Will trigger creation otherwise.
		public static DesignerSerializationBehavior Instance
		{
			get
			{	// No need for synchronization. Most likely running in single-thread environment, and creating an extra instance
				// doesn't really hurt.
				if (DesignerSerializationBehavior.instance == null)
					DesignerSerializationBehavior.instance = new DesignerSerializationBehavior ();
				return DesignerSerializationBehavior.instance;
			}
		}
	
		/// <summary>
		/// Private constructor to prevent public instantiation.
		/// </summary>
		private DesignerSerializationBehavior() : base() { }
		#endregion
	}
}

namespace Worm.Designer
{
	/// <summary>
	/// Moniker resolver for serialization behavior DesignerSerializationBehavior.
	/// </summary>
	public partial class DesignerSerializationBehaviorMonikerResolver : DslModeling::SimpleMonikerResolver
	{
		#region Member Variables
		/// <summary>
		/// Look-up directory to find serializers for domain classes.
		/// </summary>
		private DslModeling::DomainXmlSerializerDirectory directory;
		#endregion
	
		#region Constructor
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="store">Store for this moniker resolver.</param>
		/// <param name="directory">Directory to used by this resolver to look up for serializers.</param>
		public DesignerSerializationBehaviorMonikerResolver(DslModeling::Store store, DslModeling::DomainXmlSerializerDirectory directory)
			: base (store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException("directory");
			#endregion
	
			this.directory = directory;
		}
		#endregion
	
		#region Base Overrides
		/// <summary>
		/// Tells if a DomainClass can be monikerized or not.
		/// </summary>
		/// <param name="domainClassInfo">DomainClassInfo of the DomainClass to be checked.</param>
		/// <returns>True if the DomainClass can be monikerized, false otherwise.</returns>
		protected override bool CanBeMonikerized(DslModeling::DomainClassInfo domainClassInfo)
		{
			if (this.IsDisposed || this.directory == null || domainClassInfo == null)
				return false;
				
			DslModeling::DomainClassXmlSerializer serializer = this.directory.GetSerializer(domainClassInfo.Id);
			if (serializer != null)
				return (!string.IsNullOrEmpty(serializer.MonikerTagName));
			return false;
		}
			
		/// <summary>
		/// Calculate the fully qualified monikerized string of the given ModelElement.
		/// </summary>
		/// <param name="mel">ModelElement to get moniker from.</param>
		/// <returns>Calculated moniker string, returns null or empty string is the given ModelElement cannot be monikerized.</returns>
		protected override string CalculateQualifiedName(DslModeling::ModelElement mel)
		{
			if (this.IsDisposed || this.directory == null || mel == null)
				return string.Empty;
	
			string result = string.Empty;
			DslModeling::DomainClassXmlSerializer serializer = this.directory.GetSerializer(mel.GetDomainClass().Id);
			if (serializer != null)
				result = serializer.CalculateQualifiedName(this.directory, mel);
			return result;
		}
		
		/// <summary>
		/// Called at the end of synchronization when they're unresolved monikers.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to store error/warning messages.</param>
		/// <param name="moniker">Unresolved moniker.</param>
		protected override void OnUnresolvedMoniker(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			if (serializationResult != null)
			{
				DesignerSerializationBehaviorSerializationMessages.UnresolvedMoniker(serializationResult, moniker);
			}
		}
		
		/// <summary>
		/// Called when resolving a moniker causes a duplicate link to be created.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to store error/warning messages.</param>
		/// <param name="moniker">Moniker that causes duplicate link to be created.</param>
		protected override void OnMonikerResolvedToDuplicateLink(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			if (serializationResult != null)
			{
				DesignerSerializationBehaviorSerializationMessages.MonikerResolvedToDuplicateLink(serializationResult, moniker);
			}
			base.OnMonikerResolvedToDuplicateLink(serializationResult, moniker);
		}
		
		/// <summary>
		/// Called when two new elements are giving the same moniker, which will cause ambiguity during moniker resolution.
		/// </summary>
		/// <param name="context">SerializationContext to store error/warning messages.</param>
		/// <param name="moniker">Moniker that both elements give.</param>
		/// <param name="element1">The first element giving the moniker.</param>
		/// <param name="element2">The second element giving the same moniker.</param>
		protected override void OnAmbiguousMoniker(DslModeling::SerializationContext context, string moniker, DslModeling::ModelElement element1, DslModeling::ModelElement element2)
		{
			if (context != null)
			{
				DesignerSerializationBehaviorSerializationMessages.AmbiguousMoniker(context, moniker, element1, element2);
			}
			base.OnAmbiguousMoniker(context, moniker, element1, element2);
		}
		
		/// <summary>
		/// Error message for UnresolvedMonikerException.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
		protected override string UnresolvedMonikerExceptionMessage
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return DesignerSerializationBehaviorSerializationMessages.ResourceManager.GetString("CannotOpenDocument"); }
		}
		#endregion
	}
}

namespace Worm.Designer
{
	/// <summary>
	/// Utility class to provide serialization messages
	/// </summary>
	public static partial class DesignerSerializationBehaviorSerializationMessages
	{
		/// <summary>
		/// ResourceManager to get serialization messages from.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)] // Will trigger creation otherwise.
		public static global::System.Resources.ResourceManager ResourceManager
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return DesignerDomainModel.SingletonResourceManager; }
		}
	
		#region Warnings
		/// <summary>
		/// Add a warning for ambiguous schemas.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="targetNamespace">Target namespace to be resolved.</param>
		/// <param name="schemaPath">The schema that is used to resolve the definition of the target namespace.</param>
		public static void AmbiguousSchema(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string targetNamespace, string schemaPath)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(targetNamespace));
			if (string.IsNullOrEmpty(targetNamespace))
				throw new global::System.ArgumentNullException("targetNamespace");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(schemaPath));
			if (string.IsNullOrEmpty(schemaPath))
				throw new global::System.ArgumentNullException("schemaPath");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("AmbiguousSchema"),
					targetNamespace,
					schemaPath
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning when a full-form relationship seems to be serialized in short-form.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="relationshipType">Type of the relationship.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the relationship, making it MemberInfo only adds confusion.")]
		public static void ExpectingFullFormRelationship(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Type relationshipType)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(relationshipType != null);
			if (relationshipType == null)
				throw new global::System.ArgumentNullException("relationshipType");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("ExpectingFullFormRelationship"),
					reader.Name,
					relationshipType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning when a short-form relationship seems to be serialized in full-form.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="relationshipType">Type of the relationship.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the relationship, making it MemberInfo only adds confusion.")]
		public static void ExpectingShortFormRelationship(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Type relationshipType)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(relationshipType != null);
			if (relationshipType == null)
				throw new global::System.ArgumentNullException("relationshipType");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("ExpectingShortFormRelationship"),
					relationshipType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning for invalid property value with the given type, which will be ignored.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="propertyName">Name of the property.</param>
		/// <param name="propertyType">Type of the property.</param>
		/// <param name="value">Invalid value that causes this warning.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the property, making it MemberInfo only adds confusion.")]
		public static void IgnoredPropertyValue(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string propertyName, global::System.Type propertyType, string value)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(propertyType != null);
			if (propertyType == null)
				throw new global::System.ArgumentNullException("propertyType");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(propertyName));
			if (string.IsNullOrEmpty(propertyName))
				throw new global::System.ArgumentNullException("propertyName");
			#endregion
			
			if (value == null)
				value = "<null>";
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("IgnoredPropertyValue"),
					value,
					propertyName,
					propertyType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning for missing "Id" property.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="newId">Auto-generated new Id.</param>
		public static void MissingId(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Guid newId)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("MissingId"),
					newId.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture)
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
			
		/// <summary>
		/// Add an warning for moniker resolved to duplicate link. The moniker will be ignored.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to add the error message to.</param>
		/// <param name="moniker">Offending moniker.</param>
		public static void MonikerResolvedToDuplicateLink(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationResult != null);
			if (serializationResult == null)
				throw new global::System.ArgumentNullException("serializationResult");
			global::System.Diagnostics.Debug.Assert(moniker != null);
			if (moniker == null)
				throw new global::System.ArgumentNullException("moniker");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationResult,
				moniker.Location,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("MonikerResolvedToDuplicateLink"),
					moniker.MonikerName
				),
				moniker.Line,
				moniker.Column
			);
		}
		
		/// <summary>
		/// Add a warning for no schema found for the given target namespace, schema validation will be skipped in this case.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="targetNamespace">Target namespace that cannot be resolved.</param>
		public static void NoSchema(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string targetNamespace)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(targetNamespace));
			if (string.IsNullOrEmpty(targetNamespace))
				throw new global::System.ArgumentNullException("targetNamespace");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("NoSchema"),
					targetNamespace
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning for schema validation error.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="message">Validation message reported from schema validation.</param>
		public static void SchemaValidationError(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string message)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(message));
			if (string.IsNullOrEmpty(message))
				throw new global::System.ArgumentNullException("message");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				message,
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an warning for unexpected XML element.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		public static void UnexpectedXmlElement(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			#endregion
				
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("UnexpectedXmlElement"),
					reader.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		#endregion
	
		#region Errors
		/// <summary>
		/// Add an error for ambiguous moniker.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="moniker">The ambiguous moniker string.</param>
		/// <param name="element1">The first element using the given moniker.</param>
		/// <param name="element2">The second element using the given moniker.</param>
		public static void AmbiguousMoniker(DslModeling::SerializationContext serializationContext, string moniker, DslModeling::ModelElement element1, DslModeling::ModelElement element2)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(moniker != null);
			if (moniker == null)
				throw new global::System.ArgumentNullException("moniker");
			global::System.Diagnostics.Debug.Assert(element1 != null);
			if (element1 == null)
				throw new global::System.ArgumentNullException("element1");
			global::System.Diagnostics.Debug.Assert(element2 != null);
			if (element2 == null)
				throw new global::System.ArgumentNullException("element2");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("AmbiguousMoniker"),
					moniker,
					DslModeling::SerializationUtilities.GetElementName(element1),
					DslModeling::SerializationUtilities.GetElementName(element2)
				),
				null	// No location info available
			);
		}
		
		/// <summary>
		/// Add an error for not able to monikerize an instance of the given DomainClass.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="domainClassName">Name of the DomainClass whose instance cannot be monikerized.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Justification = "Generated code.")]	
		public static void CannotMonikerizeElement(DslModeling::SerializationContext serializationContext, string domainClassName)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(domainClassName));
			if (string.IsNullOrEmpty(domainClassName))
				throw new global::System.ArgumentNullException("domainClassName");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext.Result,
				null,	/* no location available for this error, because save failed. */
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("CannotMonikerizeElement"),
					domainClassName
				),
				0,
				0
			);
		}
		
		/// <summary>
		/// Add an error for dangling relationship instance.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="relationshipType">Type name of the relationship.</param>
		public static void DanglingRelationship(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string relationshipType)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(relationshipType));
			if (string.IsNullOrEmpty(relationshipType))
				throw new global::System.ArgumentNullException("relationshipType");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("DanglingRelationship"),
					relationshipType
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an error for invalid property value with given type.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="propertyName">Name of the property.</param>
		/// <param name="propertyType">Type of the property.</param>
		/// <param name="value">Invalid value that causes this error.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the property, making it MemberInfo only adds confusion.")]
		public static void InvalidPropertyValue(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string propertyName, global::System.Type propertyType, string value)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(propertyType != null);
			if (propertyType == null)
				throw new global::System.ArgumentNullException("propertyType");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(propertyName));
			if (string.IsNullOrEmpty(propertyName))
				throw new global::System.ArgumentNullException("propertyName");
			#endregion
			
			if (value == null)
				value = "<null>";
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("InvalidPropertyValue"),
					value,
					propertyName,
					propertyType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an error for missing moniker.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="monikerAttributeName">Name of the attribute that should hold the moniker.</param>
		public static void MissingMoniker(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string monikerAttributeName)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerAttributeName));
			if (string.IsNullOrEmpty(monikerAttributeName))
				throw new global::System.ArgumentNullException("monikerAttributeName");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("MissingMoniker"),
					monikerAttributeName
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an error for unresolved moniker.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to add the error message to.</param>
		/// <param name="moniker">Unresolved moniker.</param>
		public static void UnresolvedMoniker(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationResult != null);
			if (serializationResult == null)
				throw new global::System.ArgumentNullException("serializationResult");
			global::System.Diagnostics.Debug.Assert(moniker != null);
			if (moniker == null)
				throw new global::System.ArgumentNullException("moniker");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationResult,
				moniker.Location,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("UnresolvedMoniker"),
					moniker.MonikerName
				),
				moniker.Line,
				moniker.Column
			);
		}
	
		/// <summary>
		/// Add an error for Version mismatch.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="expectedVersion">The version that's expected.</param>
		/// <param name="actualVersion">Actual version from the file.</param>
		public static void VersionMismatch(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Version expectedVersion, global::System.Version actualVersion)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(expectedVersion != null);
			if (expectedVersion == null)
				throw new global::System.ArgumentNullException("expectedVersion");
			global::System.Diagnostics.Debug.Assert(actualVersion != null);
			if (actualVersion == null)
				throw new global::System.ArgumentNullException("actualVersion");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("VersionMismatch"), 
					actualVersion.ToString(4), 
					expectedVersion.ToString(4)
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		#endregion
	}
}


